<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta content="IE=edge;chrome=1" http-equiv="X-UA-Compatible" />
    <title>Androidのデータ保存パターン - Rejasupoem</title><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" /><link href="/stylesheets/all.css?1393717015" media="all" rel="stylesheet" type="text/css" /><link href="/images/favicon.ico" rel="icon" type="image/ico" />
  </head>
  <body>
    <link href="http://yandex.st/highlightjs/8.0/styles/solarized_light.min.css" rel="stylesheet" type="text/css" />
    <script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
    <script type="text/javascript">
      hljs.initHighlightingOnLoad();
    </script>
    <header class="header">
      <div class="header-inner"><a href="/">
        <div class="header-image">
          <img width="100" height="100" class="header-image-element" src="/images/rejasupotaro.jpg?1393717015" />
        </div>
        <div class="header-text">
          <h1 class="header-text-title">
            Rejasupoem
          </h1>
          <p class="header-text-description">
            deliver value to customers continuously or die;
          </p>
        </div></a>
        
      </div>
    </header>
    <hr />
    <div class="main">
      <div class="main-inner main-inner-single-article"><article class="main-article">
  <div class="main-article-header">
    <h1 class="main-article-header-title">
      Androidのデータ保存パターン
    </h1>
    <div class="main-article-header-date">
      2013-10-31
    </div>
  </div><p>新しくアプリを作るときにAndroid内でのデータの持ち方や、アクセスの仕方、モデルの扱い方には色々あってどうしようってなると思うので、僕の少ない経験から考えたことをまとめます。</p>

<h1>ファイルに保存</h1>

<p>DBは注意して使わないとデータがアップデートしたら全部消えましたとか、あるカラムだけデータが入ってませんでしたとかあるので、データの簡易保存、たとえばレスポンスのjsonをそのままキャッシュするとか、検索する必要がなかったりあまり更新しないモデルをシリアライズして保存するときにはファイル保存が向いていると思います。</p>

<p>なお、JavaのSerializableは柔軟性が低く、バージョンアップでデータを壊してアプリが落ちるということが分かっていてもハンドリングできなくて防ぐのが難しかったりするので、シリアライズするときはgsonとかmessagepackを使うことをオススメします。</p>

<p>ただこのやり方でもキャッシュを管理するためのFileManager的なクラスは必要になってくると思うので、あまり複雑なことをやるのであればDBを使った方が楽になってくると思います。
独自のFileManagerクラスを作り込んでしまうと新しく入ってきた人がつらいですしね。</p>

<h1>DBに保存(素SQL)</h1>

<p>手でSQLを書くのはつらいです。人間はミスをするのでORMを使った方がいいと思います。</p>

<h1>ORM(ActiveAndroid)を利用してDBに保存</h1>

<p><a href="http://d.hatena.ne.jp/nattou_curry_2/20090102/1230903865">ActiveRecordパターン</a>のORMです。</p>

<h2>モデル定義</h2>

<pre><code class="java">@Table(name = &quot;Items&quot;)
public class Item extends Model {
  @Column(name = &quot;Name&quot;, notNull = true, unique = true) // カラム名と制約を付けることができる　
  public String name; // ModelのFieldはpublicにしなければならない

  @Column(name = &quot;Category&quot;) // リレーションが持てる
  public Category category;
}

@Table(name = &quot;Categories&quot;)
public class Category extends Model {
  @Column(name = &quot;Name&quot;)
  public String name;

  public List&lt;Item&gt; items() {
    return getMany(Item.class, &quot;Category&quot;);
  }
}
</code></pre>

<h3>補足</h3>

<p>MedelのFieldに<a href="https://github.com/pardom/ActiveAndroid/blob/91bca4983a7da882b6585f124288f1aac7b299ef/src/com/activeandroid/Model.java#LC40">Idが定義</a>されていて、テーブルを作るときに<a href="https://github.com/pardom/ActiveAndroid/blob/91bca4983a7da882b6585f124288f1aac7b299ef/src/com/activeandroid/util/SQLiteUtils.java#LC161">Primary Keyになります。</a>
とはいえ内部的なIdだけでなく、サーバーからのレスポンスにIdも入っていると思うので、</p>

<pre><code class="java">@Table(name = &quot;Items&quot;)
public class Item extends Model {
    @Column(name = &quot;ItemId&quot;)
    public String id;

    @Column(name = &quot;Name&quot;, notNull = true, unique = true) // カラム名と制約を付けることができる　
    public String name; // ModelのFieldはpublicにしなければならない

    @Column(name = &quot;Category&quot;) // リレーションが持てる
    public Category category;
}
</code></pre>

<p>このように親クラスのIdとカラム名が被らないように定義して <code>item.id</code> でアクセスするのはどうだろうかと考えています。ここでうっかり <code>item.getId()</code> とすると思っていたのと違う値が返ってくるとかあるので注意が必要です。</p>

<p>リリース後にモデルのフィールドを変更した際にはmigrationをする必要があります。詳しくはmigrationのところで書きますが、モデルの変更は注意が必要です。</p>

<h2>Query</h2>

<h3>Save</h3>

<pre><code class="java">item = new Item();
item.category = restaurants;
item.name = &quot;Red Robin&quot;;
item.save();
</code></pre>

<h3>Delete</h3>

<pre><code class="java">Item item = Item.load(Item.class, 1);
item.delete();
// or
new Delete().from(Item.class).where(&quot;Id = ?&quot;, 1).execute();
</code></pre>

<h3>Bulk insert</h3>

<pre><code class="java">ActiveAndroid.beginTransaction();
try {
        for (int i = 0; i &lt; 100; i++) {
            Item item = new Item();
            item.name = &quot;Example &quot; + i;
            item.save();
        }
        ActiveAndroid.setTransactionSuccessful();
}
finally {
        ActiveAndroid.endTransaction();
}
</code></pre>

<p>トランザクションでラップすると40msで、使わないと4secかかるとのことです。</p>

<h3>補足</h3>

<p><a href="https://github.com/pardom/ActiveAndroid/blob/91bca4983a7da882b6585f124288f1aac7b299ef/src/com/activeandroid/query/From.java#LC54">join、leftJoin、outerJoin、innerJoin、crossJoinもできます。</a></p>

<h2>Migration</h2>

<p><code>/assets/migraions/2.sql</code> のようにsqlを置いておくとonUpgradeで実行されます。
カラムを追加するだけなら以下の書けます。</p>

<pre><code class="sql">ALTER TABLE Items ADD COLUMN price INTEGER;
</code></pre>

<p>migrationはバージョンアップ後にユーザーの手元で<a href="https://github.com/pardom/ActiveAndroid/blob/791652b3fbf130448a5b152d12764a451e421b47/src/com/activeandroid/DatabaseHelper.java#LC137">順番に実行される</a>ので、アプリをインストールしてからしばらく期間をおいてからそのユーザーがアプリのバージョンアップをしたとすると、空いた期間分のマイグレーションが走って初回起動にやや時間がかかるかと思います。(そこまで大きな影響があるとは思いませんが)
起動時間より、migrationファイルを作り忘れたとかそっちの方がこわいので、モデルを変更するとき・レビューするときには気をつけて見たほうがよさそうです。</p>

<h2>その他ORMとの比較</h2>

<pre><code class="java">// GreenDAO
List&lt;Todo&gt; ended = daoSession.getTodoDao().queryBuilder()
        .where(new StringCondition(
            TodoDao.Properties.Status.columnName + &quot;=?&quot;,
            Integer.toString(TodoDaoHelper.STATUS_END))).list();

// ActiveAndroid
new Select().from(Todo.class).where(&quot;Status=?&quot;, STATUS_END).execute();
</code></pre>

<p>greenDAOも見てみたのですが、daoSessionを引き回さないといけないのと、全体的に冗長だなという印象です。その分DAOの方がバグが入りにくそうなので、用途によって選択すればいいと思います。</p>

<p>See also:</p>

<ul>
<li><a href="http://stackoverflow.com/questions/13680954/green-dao-vs-orm-lite-vs-active-android">Green DAO vs ORM lite vs Active Android</a></li>
<li><a href="http://software-workshop.eu/content/comparing-android-orm-libraries-greendao-vs-ormlite">Comparing android ORM libraries - GreenDAO vs Ormlite</a></li>
</ul>

<h1>まとめ</h1>

<p>キャッシュはファイルに保存して、モデルは要件に応じてORMを使ってDBに保存するのがいいと思います。
もしActiveAndroidを使うならAPIレスポンスをgsonとかで直接モデルに変換するとカオスになるのでentityを作るのがいいです、みたいにデータ保存はアプリの全体設計に関わってくるので、もし新しくアプリを作る場合はなるべく早い段階から検討をするといいと思います。</p>

</article>
<p>
  <a class="twitter-share-button">"https://twitter.com/share" "Tweet"</a> 
  <script type="text/javascript">
    !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');
  </script>
</p>
      </div>
    </div>
    <footer class="footer">
      <div class="footer-inner">
        <p class="footer-copyright">
          Copyright &copy; 2013 by <a target="_blank" href="http://twitter.com/rejasupotaro">@rejasupotaro</a>
        </p>
        <p class="footer-powers">
          Powered by <a href="https://github.com/r7kamura/r7kamura.github.io">Github</a> & <a href="https://github.com/r7kamura/sitespec">Sitespec</a>
        </p>
      </div>
    </footer>
  </body>
</html>