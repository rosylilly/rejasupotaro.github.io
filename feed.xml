<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rejasupoem</title>
  <subtitle>deliver value to customers continuously or die;</subtitle>
  <id>http://rejasupotaro.github.io/</id>
  <link href="http://rejasupotaro.github.io/"/>
  <link href="http://rejasupotaro.github.io/feed.xml" rel="self"/>
  <updated>2014-02-18T00:00:00+09:00</updated>
  <author>
    <name>rejasupotaro</name>
  </author>
  <entry>
    <title>Rebuild.fmクライアント(非公式)開発の裏話</title>
    <link rel="alternate" href="http://rejasupotaro.github.io/2014/02/18/38.html"/>
    <id>http://rejasupotaro.github.io/2014/02/18/38.html</id>
    <published>2014-02-18T00:00:00+09:00</published>
    <updated>2014-02-18T08:54:29+09:00</updated>
    <author>
      <name>rejasupotaro</name>
    </author>
    <content type="html">&lt;p&gt;&lt;img src="https://raw2.github.com/rejasupotaro/Rebuild/master/screenshot.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://rejasupotaro.github.io/2014/02/17/37.html"&gt;Rebuild.fmクライアント(非公式)をリリースしました&lt;/a&gt;の開発の中で生まれたtipsや思い出を紹介しようと思います。
結構長いです。&lt;/p&gt;

&lt;h1&gt;目次&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;アプリのバージョニング&lt;/li&gt;
&lt;li&gt;RSSフィードの取得&lt;/li&gt;
&lt;li&gt;メディアの再生/停止ボタン&lt;/li&gt;
&lt;li&gt;Show Notesの表示&lt;/li&gt;
&lt;li&gt;MenuDeledate&lt;/li&gt;
&lt;li&gt;データの保存とテスト&lt;/li&gt;
&lt;li&gt;Tweetの取得&lt;/li&gt;
&lt;li&gt;FontAwesome&lt;/li&gt;
&lt;li&gt;通知の管理&lt;/li&gt;
&lt;li&gt;ライセンス表示&lt;/li&gt;
&lt;li&gt;進捗と開発のボトルネック&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;バージョニング&lt;/h1&gt;

&lt;p&gt;Android端末の設定からアプリ情報を見ると &amp;quot;バージョン0.1.2-SHA1&amp;quot; の形式になっていると思います。
Androidアプリのバージョンコードは整数でなければなりませんが、バージョン名は文字列なので、開発者が好きなように使うことができます。
たとえばビルドした日付を入れている開発者もいますし、独自に定義したコードを使っている人もいます。
僕の場合はオープンソースでやってるし、日付よりGitのログの方が有用かなと思って、このようにしました。&lt;/p&gt;

&lt;p&gt;というか思い立って調べたら&lt;a href="https://plus.google.com/+JakeWharton/posts/6f5TcVPRZij"&gt;Jake Wharton神&lt;/a&gt;の記事が出てきたので、ほぼそのとおりに設定しました。
以下、アプリのビルド設定の一部です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def versionMajor = 0
def versionMinor = 1
def versionPatch = 2
def versionBuild = 0 // bump for dogfood builds, public betas, etc.

def gitSha() {
    return &amp;#39;git rev-parse --short HEAD&amp;#39;.execute().text.trim()
}

android {
    compileSdkVersion 18
    buildToolsVersion &amp;quot;19.0.1&amp;quot;

    defaultConfig {
        minSdkVersion 14
        targetSdkVersion 18
        versionCode versionMajor * 10000 + versionMinor * 1000 + versionPatch * 100 + versionBuild
        versionName &amp;quot;${versionMajor}.${versionMinor}.${versionPatch}-${gitSha()}&amp;quot;
    }

    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じで、バージョンコードとバージョンネームの生成はコードに任せています。&lt;/p&gt;

&lt;h1&gt;RSSフィードの取得&lt;/h1&gt;

&lt;p&gt;エピソードの取得ですが、アプリの起動時に&lt;a href="http://feeds.rebuild.fm/rebuildfm"&gt;Rebuild.fmのRSS&lt;/a&gt;を取得しています。
Androidで使えるRSSクライアントが見当たらなかったので、SAXParserを使って頑張ってparseしています。&lt;/p&gt;

&lt;p&gt;一応ライブラリにしました：&lt;a href="https://github.com/rejasupotaro/AsyncRssClient"&gt;rejasupotaro / AsyncRssClient&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;今思うとjsonicとgsonを使って、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;before&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;url -&gt; [ xml -&gt; entity ] -&gt; entity
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;after&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;url, meta -&gt; [ xml -&gt; json -&gt; entity ] -&gt; entity
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうした方が良かったなと思いました。&lt;/p&gt;

&lt;h1&gt;メディアの再生/停止ボタン&lt;/h1&gt;

&lt;p&gt;最近&lt;a href="http://localhost:9292/2014/02/09/35.html"&gt;別のアプリ&lt;/a&gt;でも再生/停止ボタンを作ったのですが、&lt;/p&gt;

&lt;p&gt;&lt;img src="https://github.com/rejasupotaro/KinMozaViewer/blob/master/screenshot.png?raw=true" alt=""&gt;&lt;/p&gt;

&lt;p&gt;2つのステートを持つImageViewは、CheckBoxを使うと簡単に実装できます。&lt;/p&gt;

&lt;h3&gt;media_start_and_pause_button.xml&lt;/h3&gt;

&lt;p&gt;まず、drawableにチェックされているときと、チェックされていないときの画像を定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;selector xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&amp;gt;
    &amp;lt;item
            android:state_checked=&amp;quot;true&amp;quot;
            android:drawable=&amp;quot;@android:drawable/ic_media_pause&amp;quot; /&amp;gt;
    &amp;lt;item
            android:state_checked=&amp;quot;false&amp;quot;
            android:drawable=&amp;quot;@android:drawable/ic_media_play&amp;quot; /&amp;gt;
&amp;lt;/selector&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;style.xml&lt;/h3&gt;

&lt;p&gt;次に、Widget.CompoundButton.CheckBoxを継承したチェックボックスのスタイルを作って、drawableを上書きします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style name=&amp;quot;MediaStartAndPauseButton&amp;quot; parent=&amp;quot;android:Widget.CompoundButton.CheckBox&amp;quot;&amp;gt;
    &amp;lt;item name=&amp;quot;android:button&amp;quot;&amp;gt;@drawable/media_start_and_pause_button&amp;lt;/item&amp;gt;
    &amp;lt;item name=&amp;quot;android:layout_width&amp;quot;&amp;gt;wrap_content&amp;lt;/item&amp;gt;
    &amp;lt;item name=&amp;quot;android:layout_height&amp;quot;&amp;gt;wrap_content&amp;lt;/item&amp;gt;
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;FragmentのLayout&lt;/h3&gt;

&lt;p&gt;チェックボックスに定義したスタイルを適用します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;CheckBox
        android:id=&amp;quot;@+id/media_play_and_pause_button&amp;quot;
        style=&amp;quot;@style/MediaPlayAndPauseButton&amp;quot;
        android:layout_marginLeft=&amp;quot;@dimen/margin_icon_button&amp;quot;
        android:layout_gravity=&amp;quot;center&amp;quot;
        /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうすることでOn/Off時の画像の切り替えのコードを書かなくてよくなります。また、&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;mMediaStartAndPauseButton.setOnCheckedChangeListener(
        new CompoundButton.OnCheckedChangeListener() {
            @Override
            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
                if (isChecked) {
                    start(episode);
                } else {
                    pause();
                }
            }
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OnCheckedChangeListenerが使えたり、isCheckedメソッドが使えたりして、かなり具合がいいです。&lt;/p&gt;

&lt;h1&gt;Show Notesの表示&lt;/h1&gt;

&lt;p&gt;書いてる途中で寝てしまったのでうちに帰ってから書く。&lt;/p&gt;

&lt;h1&gt;MenuDeledate&lt;/h1&gt;

&lt;p&gt;書いてる途中で寝てしまったのでうちに帰ってから書く。&lt;/p&gt;

&lt;h1&gt;データの保存とテスト&lt;/h1&gt;

&lt;p&gt;書いてる途中で寝てしまったのでうちに帰ってから書く。&lt;/p&gt;

&lt;h1&gt;Tweetの取得&lt;/h1&gt;

&lt;p&gt;書いてる途中で寝てしまったのでうちに帰ってから書く。&lt;/p&gt;

&lt;h1&gt;FontAwesome&lt;/h1&gt;

&lt;p&gt;書いてる途中で寝てしまったのでうちに帰ってから書く。&lt;/p&gt;

&lt;h1&gt;通知の管理&lt;/h1&gt;

&lt;p&gt;書いてる途中で寝てしまったのでうちに帰ってから書く。&lt;/p&gt;

&lt;h1&gt;ライセンス画面&lt;/h1&gt;

&lt;p&gt;書いてる途中で寝てしまったのでうちに帰ってから書く。&lt;/p&gt;

&lt;h1&gt;進捗と開発のボトルネック&lt;/h1&gt;

&lt;p&gt;&lt;img src="https://dl.dropboxusercontent.com/u/54255753/blog/201402/frequency.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Code Frequencyをご覧のとおり、11月に着手してその一週間後に機能的にはほぼ完成していました。
そのあと忙しくなってあまり時間が取れずに2月のリリースになったのですが、何がそんな大変だったのかというと、UXとかUIを考えるのにすごく時間がかかりました。&lt;/p&gt;

&lt;p&gt;&lt;img src="https://dl.dropboxusercontent.com/u/54255753/blog/201402/episode_detail_fragment.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;XMLを書いては端末にインストールして確認し、場合によってはFragmentにしたりActivityに戻したりしながら進めてるので、すごく時間がかかっています。
チームで開発しているときは、各々が得意分野をやりますが、一人だと全部自分でしないといけないので、自分の弱点がそのまま開発のボトルネックになるということを実感しました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;リポジトリはこちら：&lt;a href="https://github.com/rejasupotaro/Rebuild"&gt;rejasupotaro / Rebuild&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Rebuild.fmクライアント(非公式)をリリースしました</title>
    <link rel="alternate" href="http://rejasupotaro.github.io/2014/02/17/37.html"/>
    <id>http://rejasupotaro.github.io/2014/02/17/37.html</id>
    <published>2014-02-17T00:00:00+09:00</published>
    <updated>2014-02-18T09:22:37+09:00</updated>
    <author>
      <name>rejasupotaro</name>
    </author>
    <content type="html">&lt;h2&gt;Rebuild.fm for Android (Unofficial)&lt;/h2&gt;

&lt;p&gt;&lt;img src="https://raw2.github.com/rejasupotaro/Rebuild/master/screenshot.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Rebuild.fm for Androidとは、&lt;a href="https://twitter.com/miyagawa"&gt;miyagawaさん&lt;/a&gt;のPodcast、&lt;a href="http://rebuild.fm/"&gt;Rebuild.fm&lt;/a&gt;専用のPodcastアプリです。&lt;/p&gt;

&lt;p&gt;このアプリ自体はオープンソースで開発していて、READMEにインストール手順は書いてあるのですが、あまり使ってくれる人がいませんでした。
開発するモチベーションを保つためにフィードバックが欲しくて、マーケットに出そうかなという話をmiyagawaさんにしたら快諾してくれたので、この度リリースしました。&lt;/p&gt;

&lt;p&gt;(本当は一周年記念に合わせてリリースしたかったけど、リリース準備してたら一部端末でOOMになるバグが見つかったりして間に合わなかった)&lt;/p&gt;

&lt;h2&gt;「Rebuild.fm専用？それって機能が限定されたPodcastアプリでは？」&lt;/h2&gt;

&lt;p&gt;よくあるPodcastアプリは無機質な感じで、よりRebuild.fmの世界観を表現したいと思ったからとか、twitterがテキストを140字に制限することで使いやすさを実現しているように、Rebuild.fmに限定することで使いたすくしたかった、という優等生的な回答をしつつ、実際のところは僕がPodcastはRebuild.fmしか聴いていなかったので、Rebuild.fmに特化した使いやすいアプリが欲しかったというのが一番の理由でした。&lt;/p&gt;

&lt;p&gt;使いやすさについて考えるために、僕とRebuild.fmの関わり方について考えました。&lt;/p&gt;

&lt;h2&gt;僕とRebuild.fm&lt;/h2&gt;

&lt;p&gt;「Rebuild.fmで言ってたけど、鳥はAndroidの方がやりやすいよね」とか「ほら、この前Rebuild.fmで言ってた〜」みたいに、エンジニアと話すとRebuild.fmが話題になったり、ブログとかイベントでネタにされていたりとか、あとは新しいエピソードが公開されたあと、みんなはどういう感想を持ったんだろうと思いながらtwitterでハッシュタグを追ったりとか、こういうことを図にしてみたら下のようになりました。&lt;/p&gt;

&lt;p&gt;&lt;img src="https://dl.dropboxusercontent.com/u/54255753/blog/201402/miyagawa.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;抽象的な図になってしまったのでもう少し分かりやすく説明すると、僕が小学生の頃には笑う犬の生活という番組が流行っていて、放送されると翌日に「見た？面白かったよね！」っていう話をみんなしてて、番組を見てると話の輪に入れるみたいな、そんな感じです。&lt;/p&gt;

&lt;h2&gt;Rebuild.fmアプリの見せ方&lt;/h2&gt;

&lt;p&gt;というわけで、Rebuild.fm本家の雰囲気を踏襲したデザインにしつつ、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;エピソードに対する周りの人の反応をどう見せるか&lt;/li&gt;
&lt;li&gt;いかにしてエピソード内の情報を見やすくするか&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ということを考えて作りました。
考えて作ったというだけで、今のところ自分が納得できるクオリティになっているかというと、そうは思いません。
ですが、リリース日を伸ばすのも良くないと思い、version 0.1という位置付けでリリースしました。&lt;/p&gt;

&lt;p&gt;ダウンロードは下のリンクからどうぞ。&lt;/p&gt;

&lt;p&gt;&lt;a href="https://play.google.com/store/apps/details?id=rejasupotaro.rebuild"&gt;&lt;img src="https://dl.dropboxusercontent.com/u/54255753/blog/201402/en_generic_rgb_wo_60.png" alt=""&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;リポジトリはこちら：&lt;a href="https://github.com/rejasupotaro/Rebuild"&gt;rejasupotaro / Rebuild&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;開発の裏話は別の記事にしました：&lt;a href="http://rejasupotaro.github.io/2014/02/18/38.html"&gt;Rebuild.fmクライアント(非公式)開発の裏話&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;どうぞよろしくお願いします。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>How to build a career through github activities</title>
    <link rel="alternate" href="http://rejasupotaro.github.io/2014/02/11/36.html"/>
    <id>http://rejasupotaro.github.io/2014/02/11/36.html</id>
    <published>2014-02-11T00:00:00+09:00</published>
    <updated>2014-02-12T14:15:38+09:00</updated>
    <author>
      <name>rejasupotaro</name>
    </author>
    <content type="html">&lt;script async class="speakerdeck-embed" data-id="d07deda0755701312eb91a125ab0a9e4" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"&gt;&lt;/script&gt;

&lt;p&gt;&lt;a href="https://github.com/potatotips/potatotips/wiki/potatotips-4"&gt;potatotips-4&lt;/a&gt; で自分が作ったライブラリをどうやって使ってもらうかという話をしました。
元ネタはninjinkunさんの&lt;a href="http://www.slideshare.net/ninjinkun/i-os-30692824"&gt;GitHub活動を通して個人のキャリアを積みつつ仕事の成果を出す方法&lt;/a&gt;です。
持ち時間が5分だったので、時間の都合上端折った箇所を補足します。&lt;/p&gt;

&lt;h1&gt;1. 試しやすくする&lt;/h1&gt;

&lt;h3&gt;サンプルアプリを付ける　&lt;/h3&gt;

&lt;p&gt;サンプルがあるとどういう動きをするのか実際にさわって分かるというのと、それ自体がドキュメントとしての役割を持つので、ライブラリ導入のハードルを下げると思います。
それと、ライブラリを開発しているときも一旦どこかにデプロイして〜とかしなくてもよくなるので、開発スピードが上がります。&lt;/p&gt;

&lt;h1&gt;2. 組み込みやすくする&lt;/h1&gt;

&lt;p&gt;いざ自分のプロジェクトにライブラリを入れようと思ったときに、インストールの仕方が書いてないとアッアッとなります。
そこで開発者が離れていってしまうのはもったいないので、インストール手順は書いた方がいいです。&lt;/p&gt;

&lt;h3&gt;githubにrepositoryとして使う&lt;/h3&gt;

&lt;p&gt;maven-metadata.xmlとファイルの実体さえあえば、どこでもmavenリポジトリにすることができます。
gradleの例ですが、以下のような記述を &lt;code&gt;projectDir/build.gradle&lt;/code&gt; に追加して、&lt;/p&gt;

&lt;pre&gt;&lt;code class="groovy"&gt;apply plugin: &amp;#39;android-library&amp;#39;
apply plugin: &amp;#39;maven&amp;#39;

uploadArchives {
    repositories {
        mavenDeployer {
            repository url: &amp;quot;file://${projectDir}/repository&amp;quot;
            pom.groupId = &amp;#39;rejasupotaro&amp;#39;
            pom.artifactId = &amp;#39;my-library&amp;#39;
            pom.version = &amp;#39;0.0.1&amp;#39;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コマンドを実行すると、&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ gradle uploadArchives
$ tree repository
repository
└── rejasupotaro
    └── my-library
        ├── 0.0.1
        │   ├── my-library-0.0.1.aar
        │   ├── my-library-0.0.1.aar.md5
        │   ├── my-library-0.0.1.aar.sha1
        │   ├── my-library-0.0.1.pom
        │   ├── my-library-0.0.1.pom.md5
        │   └── my-library-0.0.1.pom.sha1
        ├── maven-metadata.xml
        ├── maven-metadata.xml.md5
        └── maven-metadata.xml.sha1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このようになります。
これをコミットしてプッシュします。&lt;/p&gt;

&lt;h3&gt;github上のrepositoryからdependencyを解決する&lt;/h3&gt;

&lt;p&gt;githubのファイルには &lt;code&gt;raw.github.com&lt;/code&gt; でアクセスできるので、repositoriesにgithubのurlを指定して、dependenciesに追加すれば、ライブラリを使うことができるようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class="groovy"&gt;repositories {
    ...
    maven { url &amp;#39;https://raw.github.com/rejasupotaro/MyLibrary/master/library/repository&amp;#39; }
}

dependencies {
    ...
    compile &amp;#39;rejasupotaro:my-library:0.0.1&amp;#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;ローカルでjarにする&lt;/h2&gt;

&lt;p&gt;リソースもいらないし手元で、jarに出来ればよいという場合には、以下のようにすればいいと思います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apply plugin: &amp;#39;java&amp;#39;

group = &amp;#39;rejasupotaro&amp;#39;
archivesBaseName = &amp;#39;my-library&amp;#39;
version = &amp;#39;0.0.1&amp;#39;

sourceSets {
    main {
        java {
            srcDir &amp;#39;src/main/java&amp;#39;
        }
    }
}

dependencies {
    compile fileTree(dir: &amp;#39;libs&amp;#39;, include: &amp;#39;*.jar&amp;#39;)
}

task sourcesJar(type: Jar) {
    classifier = &amp;#39;sources&amp;#39;
    from sourceSets.main.allSource
}

artifacts {
    archives sourcesJar
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$ gradle jar&lt;/code&gt; を実行すると &lt;code&gt;src/main/java&lt;/code&gt; 以下のclassファイルとManifestのarchive(jar)が作成されます。&lt;/p&gt;

&lt;p&gt;pluginが他のプラグインとぶつかるときは、環境変数で切り替えたりしています。
たとえばjarを作るときはリリース時なので &lt;code&gt;$ gradle jar -Penv=release&lt;/code&gt; みたいな。&lt;/p&gt;

&lt;h1&gt;3. 品質を高める&lt;/h1&gt;

&lt;p&gt;テストをどう書くか、という話はここではしませんが、少なくともテストのないライブラリは積極的に使おうという気にはならないですよね。
テストに加えて、CIが通ったバッチがREADMEについてると、なお安心感があります。&lt;/p&gt;

&lt;p&gt;どのCIサービスを使うかという話ですが、好みがあると思いますが、僕は一応Wercker推しです。
以下、非常に偏った比較です。&lt;/p&gt;

&lt;h3&gt;Wercker&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;何も書かなくてもデフォルトのビルドファイルを適用してくれる&lt;/li&gt;
&lt;li&gt;あらかじめビルド環境(Box)が用意されている&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/wercker/box-android"&gt;wercker / box-android&lt;/a&gt;が公開されてる&lt;/li&gt;
&lt;li&gt;submoduleを自動で取ってきてくれる&lt;/li&gt;
&lt;li&gt;あと何秒みたいなのが表示されたり、グラフィカルなBuild Statsがあったり、UIが洗練されている&lt;/li&gt;
&lt;li&gt;ビルドがTravisと比べて速い&lt;/li&gt;
&lt;li&gt;ログはリアルタイムに更新されない&lt;/li&gt;
&lt;li&gt;デプロイまで面倒を見てくれる&lt;/li&gt;
&lt;li&gt;まだβ版なので今後どうなるかは分からない&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Circle CI&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ちょっと洗練されたTravis(イメージ)&lt;/li&gt;
&lt;li&gt;結構ビジネスって使ってるって聞きます&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Travis&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;個人の開発者とか、OSSで一番よく使われている&lt;/li&gt;
&lt;li&gt;最初は設定が面倒だけど、一度設定すれば設定ファイルをコピペでいける&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;サーバーのセットアップ&lt;/h3&gt;

&lt;p&gt;社内のAndroidのビルド環境のセットアップを丹精込めて手作業で行なってきたけど、最近物忘れが激しくて &lt;code&gt;android…update…filter…?no-ui…???&lt;/code&gt; みたいにコマンドがうろ覚え状態ということもあり、CIサーバーのセットアップを自動化できないかと思って流行りのchefとかfabricとかserverspecとかを使ってみたけど、&lt;a href="https://github.com/embarkmobile/android-sdk-installer"&gt;android-sdk-installer&lt;/a&gt;を使うというところに落ち着きました。&lt;/p&gt;

&lt;p&gt;これのいいところは、Travisを使っている人は分かると思いますが、毎回 &lt;code&gt;wait_for_emulator&lt;/code&gt; をコピペしていたのが、ツールの中に入ってるのが良かったです。&lt;/p&gt;

&lt;h1&gt;4. 表現を工夫する&lt;/h1&gt;

&lt;p&gt;UIのライブラリはgifアニメがあるだけで印象がだいぶ変わります。
あとライセンスがREADMEに書いてあるものも、僕的にポイント高いです。&lt;/p&gt;

&lt;p&gt;&lt;img height="200" src="https://github-camo.global.ssl.fastly.net/d20ac6fb1cb14db4b69ab5e48ebd609aab1f6831/687474703a2f2f6f70656e61706869642e6769746875622e636f6d2f696d616765732f666c6970766965772d686f72697a6f6e74616c2d64656d6f2e676966"&gt;
&lt;img height="200" src="http://gifzo.net/jTEl4YmZqD.gif"&gt;
&lt;img height="200" src="http://gifzo.net/BWvNCrQFYfF.gif"&gt;
&lt;img height="200" src="http://gifzo.net/68NrYQW2tB.gif"&gt;
&lt;img height="200" src="http://gifzo.net/lSwyh4fg6P.gif"&gt;
&lt;img height="200" src="http://gifzo.net/OKyqq1D9yD.gif"&gt;&lt;/p&gt;

&lt;p&gt;みたいな。&lt;/p&gt;

&lt;h1&gt;5. 広報&lt;/h1&gt;

&lt;p&gt;READMEはインストール方法とか、ライブラリの使い方とかしか書けないけど、ブログならどういう問題があって、どういうアプローチで解決したかみたいな背景も書けるので、そういうのを知ると使ってみようかなっていう気になるし、それに拡散できるのでよいです。&lt;/p&gt;

&lt;h1&gt;おわりに&lt;/h1&gt;

&lt;p&gt;&lt;img src="https://dl.dropboxusercontent.com/u/54255753/blog/201402/activities.png" alt=""&gt;
&lt;img src="https://dl.dropboxusercontent.com/u/54255753/blog/201402/aizen.png" alt=""&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>KinMozaView is updated!!</title>
    <link rel="alternate" href="http://rejasupotaro.github.io/2014/02/09/35.html"/>
    <id>http://rejasupotaro.github.io/2014/02/09/35.html</id>
    <published>2014-02-09T00:00:00+09:00</published>
    <updated>2014-02-12T14:14:50+09:00</updated>
    <author>
      <name>rejasupotaro</name>
    </author>
    <content type="html">&lt;h2&gt;きんモザビューワーをアップデートしました！&lt;/h2&gt;

&lt;p&gt;&lt;img src="https://github.com/rejasupotaro/KinMozaViewer/blob/master/screenshot.png?raw=true" alt=""&gt;&lt;/p&gt;

&lt;h2&gt;主な変更点は2点！&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;自動再生機能を追加しました！&lt;/li&gt;
&lt;li&gt;再生中に画面をスリープしないようにしました！&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://github.com/rejasupotaro/KinMozaViewer/blob/master/screenshot.png?raw=true" alt=""&gt;&lt;/p&gt;

&lt;p&gt;ダウンロード(というかビルド)は&lt;a href="https://github.com/rejasupotaro/KinMozaViewer"&gt;GitHub&lt;/a&gt;からどうぞ！&lt;/p&gt;

&lt;p&gt;&lt;a href="http://rejasupotaro.github.io/2013/10/31/8.html"&gt;リリースしたときに書いたブログ&lt;/a&gt;はリンクを貼っただけだったので、ちょっと技術的な話をします。&lt;/p&gt;

&lt;h2&gt;gifの表示について&lt;/h2&gt;

&lt;p&gt;表示しているgifは&lt;a href="http://mogashi.hateblo.jp/entry/2013/09/24/000619"&gt;APIで取得している&lt;/a&gt;のですが、Androidでgifを表示するにはかなり頑張らないといけないので、WebViewで表示するようにしました。&lt;/p&gt;

&lt;p&gt;assetsにテンプレートを置いておいて、APIで取得したURLと動的に取得した画面幅を組み込んで、loadDataWithBaseURLでコンテンツをWebViewに流しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;String imageUrl = UrlUtils.buildAliceUrl(ep, no);
String content = mTemplate.compile(imageUrl);
loadDataWithBaseURL(&amp;quot;&amp;quot;, content, &amp;quot;text/html&amp;quot;, HTTP.UTF_8, null);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;自動再生について&lt;/h2&gt;

&lt;p&gt;一定時間おきにタスクを実行するコードをよく書く気がしたので、汎用的なクラスを作りました。
コンストラクタにRunnableとインターバル値を入れます。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public class PeriodicTimerTask {

    private Handler mHandler = new Handler();

    private Runnable mTask;

    private int mTaskIntervalMs;

    private TimerTask mTimerTask;

    private Timer mTimer;

    private TimerTask newTimerTask() {
        return new TimerTask() {
            @Override
            public void run() {
                mHandler.post(mTask);
            }
        };
    }

    private Timer newTimer() {
        return new Timer(true);
    }

    public PeriodicTimerTask(Runnable task, int taskIntervalMs) {
        mTask = task;
        mTaskIntervalMs = taskIntervalMs;
    }

    public void start() {
        if (mTimer == null) {
            mTimerTask = newTimerTask();
            mTimer = newTimer();
            mTimer.schedule(mTimerTask, 0, mTaskIntervalMs);
        }
    }

    public void stop() {
        if (mTimer != null) {
            mTimer.cancel();
            mTimer = null;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;たとえばこのアプリでは、自動再生モードがオンのとき、SeekBarを一定時間おきに動かしています。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public class MediaTimerTask extends PeriodicTimerTask {

    private static final int TASK_INTERVAL_MS = 500;

    private static final int PROGRESS_INCREMENT = 10;

    public MediaTimerTask(final SeekBar seekBar) {
        super(new Runnable() {
            @Override
            public void run() {
                if (seekBar == null) {
                    return;
                }

                int progress = seekBar.getProgress();
                if (progress &amp;gt;= seekBar.getMax()) {
                    progress = 0;
                } else {
                    progress += PROGRESS_INCREMENT;
                }
                seekBar.setProgress(progress);
            }
        }, TASK_INTERVAL_MS);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SeekBarでは進捗(Progress)に変化があったときに、進捗値から何章のどこら辺かを計算して、そのパラメータを付けてAPIを叩いて、画面を更新します。&lt;/p&gt;

&lt;h2&gt;アプリをスリープさせない&lt;/h2&gt;

&lt;p&gt;MainActivityのonCreate相当のところで下のような処理をしています。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;private void keepScreenOn() {
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;アイコンを作る&lt;/h2&gt;

&lt;p&gt;アイコンを作るのに&lt;a href="http://android-ui-utils.googlecode.com/hg/asset-studio/dist/index.html"&gt;Android Asset Studio&lt;/a&gt;を使おうとするんだけど、Android Asset Studioだと角丸ができないので、調べたら&lt;a href="http://www.gieson.com/Library/projects/utilities/icon_slayer/"&gt;Icon Slayer&lt;/a&gt;っていうのが出てきて、それを使っています。&lt;/p&gt;

&lt;p&gt;&lt;img src="https://dl.dropboxusercontent.com/u/54255753/blog/201402/icon_generator.png" alt=""&gt;&lt;/p&gt;

&lt;h2&gt;効果的な使用方法&lt;/h2&gt;

&lt;p&gt;手元のAndroid搭載プロジェクタにこのアプリを入れて、部屋を暗くしてコードを書いてる後ろでエンドレスで再生し続けます。&lt;/p&gt;

&lt;p&gt;&lt;img src="https://dl.dropboxusercontent.com/u/54255753/blog/201402/projector.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;6畳に物が散乱している狭い部屋を、生ぬるいくらいの温度にして、プロジェクタとノートPCの光だけが部屋を照らしている中、寝落ちするまでコードを書く。
よく分からないけどこの生活が癖になってしまって、とにかく昼間眠い。&lt;/p&gt;

&lt;p&gt;&lt;img src="https://github.com/rejasupotaro/KinMozaViewer/blob/master/screenshot.png?raw=true" alt=""&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>ListViewのデータのbindはこうする2014</title>
    <link rel="alternate" href="http://rejasupotaro.github.io/2014/02/06/34.html"/>
    <id>http://rejasupotaro.github.io/2014/02/06/34.html</id>
    <published>2014-02-06T00:00:00+09:00</published>
    <updated>2014-02-12T14:14:50+09:00</updated>
    <author>
      <name>rejasupotaro</name>
    </author>
    <content type="html">&lt;p&gt;基本の割に初心者にとって使うのにハードルが高いview、ListView。
ネット調べると色んなパターンで書かれた例が出てくると思います。&lt;/p&gt;

&lt;p&gt;何も知らずにAndroid 1.6とかの時代に書かれたような出どころが不明なサンプルコードをコピペしてうまくいかなくて心が折れるみたいなことを防ぐために、インターネットに出回っているサンプルコードをパターン化して列挙しました。パターン1が一番良くなくて、パターン3あるいはパターン4にするといいと思います。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://www.geek.com/wp-content/uploads/2009/10/settings.JPG" width="120"&gt;&lt;/p&gt;

&lt;p&gt;インターネットで調べててAndroid 1.6とか2系の葬式UIが出てきたら、それは昔に書かれたものでそっと閉じたほうがいいです。&lt;/p&gt;

&lt;h1&gt;Adapterとは&lt;/h1&gt;

&lt;p&gt;AdapterはviewとDataSourceの橋渡しをするものです。&lt;/p&gt;

&lt;p&gt;&lt;a href="http://www.edureka.in/blog/what-are-adapters-in-android/"&gt;&lt;img src="http://www.edureka.in/blog/wp-content/uploads/2013/03/adapters.jpg" alt=""&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;private void setupListView(List&amp;lt;User&amp;gt; userList) {
    UserAdapter adapter = new UserAdapter(context, resourceId, userList);
    // Viewに直接データを渡すのではなく、Adapterを渡す
    mListView.setAdapter(adapter);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、viewは生成のコストが高いので、AndroidフレームワークにViewを使い回すしくみがあります。&lt;/p&gt;

&lt;p&gt;&lt;a href="http://android.amberfog.com/?p=296"&gt;&lt;img src="http://android.amberfog.com/wp-content/uploads/2010/02/listview_recycler.jpg" alt=""&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;1. viewがgetされるたびに生成&lt;/h1&gt;

&lt;p&gt;viewが描画位置に入るとgetViewが呼ばれて、viewを生成して返すとそれが描画されます。
recycle poolの存在を知らないと、その都度生成してしまってListViewの描画がガタガタになります(僕も昔やってました)。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public class SampleAdapter1 extends ArrayAdapter&amp;lt;User&amp;gt; {

    public SampleAdapter1(Context context, int resource, List&amp;lt;User&amp;gt; objects) {
        super(context, resource, objects);
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        View view = View.inflate(getContext(), R.layout.list_item_user, parent);

        User user = getItem(position);

        TextView numberTextView = (TextView) view.findViewById(R.id.number);
        numberTextView.setText(String.valueOf(position));

        ImageView userThumbnailImageView = (ImageView) view.findViewById(R.id.user_thumbnail);
        new SetBitmapFromNetworkTask(userThumbnailImageView).execute(user.getThumbnailUrl());

        TextView userNameTextView = (TextView) view.findViewById(R.id.user_name);
        userNameTextView.setText(user.getName());

        TextView userBiographyTextView = (TextView) view.findViewById(R.id.user_biography);
        userBiographyTextView.setText(user.getBiography());

        return view;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;2. convertViewがnullのときにだけ生成&lt;/h1&gt;

&lt;p&gt;recycle poolからreuseされたviewはconvertViewに入ってくるので、convertViewがnullじゃなければ、中身だけを書き換えて再利用するようにしたコードが以下です。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public class SampleAdapter2 extends ArrayAdapter&amp;lt;User&amp;gt; {

    public SampleAdapter2(Context context, int resource, List&amp;lt;User&amp;gt; objects) {
        super(context, resource, objects);
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        if (convertView == null) {
            convertView = View.inflate(getContext(), R.layout.list_item_user, parent);
        }

        User user = getItem(position);

        TextView numberTextView = (TextView) convertView.findViewById(R.id.number);
        numberTextView.setText(String.valueOf(position));

        ImageView userThumbnailImageView = (ImageView) convertView.findViewById(R.id.user_thumbnail);
        new SetBitmapFromNetworkTask(userThumbnailImageView).execute(user.getThumbnailUrl());

        TextView userNameTextView = (TextView) convertView.findViewById(R.id.user_name);
        userNameTextView.setText(user.getName());

        TextView userBiographyTextView = (TextView) convertView.findViewById(R.id.user_biography);
        userBiographyTextView.setText(user.getBiography());

        return convertView;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;3. convertViewがnullのときにだけ生成 + ViewHolderにviewをキャッシュ&lt;/h1&gt;

&lt;p&gt;convertViewが使いまわされたリストの一行のviewなのですが、その中のviewを毎回探索するのは無駄なので、ViewHolderクラスを作ってキャッシュさせます。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public class SampleAdapter3 extends ArrayAdapter&amp;lt;User&amp;gt; {

    private static class ViewHolder {
        TextView numberTextView;
        ImageView userThumbnailImageView;
        TextView userNameTextView;
        TextView userBiographyTextView;

        public ViewHolder(View view) {
            this.numberTextView = (TextView) view.findViewById(R.id.number);
            this.userThumbnailImageView = (ImageView) view.findViewById(R.id.user_thumbnail);
            this.userNameTextView = (TextView) view.findViewById(R.id.user_name);
            this.userBiographyTextView = (TextView) view.findViewById(R.id.user_biography);
        }
    }

    public SampleAdapter3(Context context, int resource, List&amp;lt;User&amp;gt; objects) {
        super(context, resource, objects);
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        ViewHolder holder;
        if (convertView == null) {
            convertView = View.inflate(getContext(), R.layout.list_item_user, parent);
            holder = new ViewHolder(convertView);
            convertView.setTag(holder);
        } else {
            holder = (ViewHolder) convertView.getTag();
        }

        User user = getItem(position);

        holder.numberTextView.setText(String.valueOf(position));
        new SetBitmapFromNetworkTask(holder.userThumbnailImageView).execute(user.getThumbnailUrl());
        holder.userNameTextView.setText(user.getName());
        holder.userBiographyTextView.setText(user.getBiography());

        return convertView;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;4. BindableAdapterを使う&lt;/h1&gt;

&lt;p&gt;「convertViewがnullのときは新しくviewを生成して、nullじゃなかったらViewに値をセットして」をコードに落としこむとこうなる感じです。
IDEのデフォルト機能でViewHolder以外のコードを生成できるので、コンストラクタの引数で迷わないし、型パラメータのおかげでitemをそのままViewにbindできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public class SampleAdapter4 extends BindableAdapter&amp;lt;User&amp;gt; {

    public SampleAdapter4(Context context, List&amp;lt;User&amp;gt; episodeList) {
        super(context, episodeList);
    }

    private static class ViewHolder {
        private TextView numberTextView;
        private ImageView userThumbnailImageView;
        private TextView userNameTextView;
        private TextView userBiographyTextView;

        ViewHolder(View view) {
            numberTextView = (TextView) view.findViewById(R.id.number);
            userThumbnailImageView = (ImageView) view.findViewById(R.id.user_thumbnail);
            userNameTextView = (TextView) view.findViewById(R.id.user_name);
            userBiographyTextView = (TextView) view.findViewById(R.id.user_biography);
        }
    }

    @Override
    public View newView(LayoutInflater inflater, int position, ViewGroup container) {
        View view =  inflater.inflate(R.layout.list_item_user, container, false);
        ViewHolder holder = new ViewHolder(view);
        view.setTag(holder);
        return view;
    }

    @Override
    public void bindView(User item, int position, View view) {
        ViewHolder holder = (ViewHolder) view.getTag();

        holder.numberTextView.setText(String.valueOf(position));
        new SetBitmapFromNetworkTask(holder.userThumbnailImageView).execute(item.getThumbnailUrl());
        holder.userNameTextView.setText(item.getName());
        holder.userBiographyTextView.setText(item.getBiography());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="java"&gt;public abstract class BindableAdapter&amp;lt;T&amp;gt; extends ArrayAdapter&amp;lt;T&amp;gt; {

    private LayoutInflater mInflater;

    public BindableAdapter(Context context, List&amp;lt;T&amp;gt; episodeList) {
        super(context, 0, episodeList);
        setup(context);
    }

    private void setup(Context context) {
        mInflater = LayoutInflater.from(context);
    }

    @Override
    public final View getView(int position, View view, ViewGroup container) {
        if (view == null) {
            view = newView(mInflater, position, container);
            if (view == null) {
                throw new IllegalStateException(&amp;quot;newView result must not be null.&amp;quot;);
            }
        }
        bindView(getItem(position), position, view);
        return view;
    }

    public abstract View newView(LayoutInflater inflater, int position, ViewGroup container);

    public abstract void bindView(T item, int position, View view);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でもViewHolderを手で書いたり、pluginで生成するのもあれなんですよね、 &lt;strong&gt;まさか来週の&lt;a href="https://github.com/potatotips/potatotips/wiki/potatotips-4"&gt;potatotips&lt;/a&gt;で@__gfx__さんがgradleでxmlからジャバコードを自動生成するわけじゃあるまいし(前フリ)&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>第7章 型や型クラスを自分で作ろう 後編</title>
    <link rel="alternate" href="http://rejasupotaro.github.io/2014/02/02/33.html"/>
    <id>http://rejasupotaro.github.io/2014/02/02/33.html</id>
    <published>2014-02-02T00:00:00+09:00</published>
    <updated>2014-02-12T14:14:50+09:00</updated>
    <author>
      <name>rejasupotaro</name>
    </author>
    <content type="html">&lt;h1&gt;前回やったこと&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;データ型の定義&lt;/li&gt;
&lt;li&gt;データ型のエクスポート&lt;/li&gt;
&lt;li&gt;レコード構文&lt;/li&gt;
&lt;li&gt;多相型と型引数&lt;/li&gt;
&lt;li&gt;インスタンスの自動導出&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/knjname/status/427053066030833664 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/nobkz/status/428789457068646401 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/nida_001/status/428789602015387648 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/tail_y/status/428822946719604736 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/VoQn/status/429091683783806976 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1&gt;今回やること&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;型シノニム

&lt;ul&gt;
&lt;li&gt;型シノニムの多相化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;再帰的なデータ構造&lt;/li&gt;
&lt;li&gt;演算子の定義&lt;/li&gt;
&lt;li&gt;型クラス

&lt;ul&gt;
&lt;li&gt;型クラスの定義&lt;/li&gt;
&lt;li&gt;型クラスのサブクラス&lt;/li&gt;
&lt;li&gt;型クラス制約&lt;/li&gt;
&lt;li&gt;多相性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Functor型クラス&lt;/li&gt;
&lt;li&gt;型の種類&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;型と新しい型(type and newtype)&lt;/h1&gt;

&lt;h2&gt;type&lt;/h2&gt;

&lt;p&gt;何章か前に出てきましたが &lt;code&gt;[Char]&lt;/code&gt; と &lt;code&gt;String&lt;/code&gt; は同値で、交換可能です。
ghciで &lt;code&gt;:i String&lt;/code&gt; としてみてください。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :i String
type String = [Char]    -- Defined in `GHC.Base&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;type 型構築子 型引数1 型引数2 ... = 元の型
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;typeは型のシノニムが定義されているのであって、新しい型が作られている訳ではありません。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ちょっと復習ですが、名前、年齢、身長、体重、電話番号を持つUserを表すデータ型は、&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;data User = User String Int Float Float String
    deriving (Show)

name :: User -&gt; String
name (User name _ _ _ _ ) = name

age :: User -&gt; Int
age (User _ age _ _ _) = age

height :: User -&gt; Float
height (User _ _ height _ _) = height

weight :: User -&gt; Float
weight (User _ _ _ weight _) = weight

phoneNumber :: User -&gt; String
phoneNumber (User _ _ _ _ phoneNumber) = phoneNumber
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このようになって、値構築子(値コンストラクタ)は関数なので &lt;code&gt;:type&lt;/code&gt; で型シグネチャを見ることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :t User
User :: String -&gt; Int -&gt; Float -&gt; Float -&gt; String -&gt; User
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;型シグネチャだけ見ても何を渡せばいいのか分からないということで、レコード構文もやりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;data User = User { name :: String
                 , age :: Int
                 , height :: Float
                 , weight :: Float
                 , phoneNumber :: String } deriving (Show)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :t User
User :: String -&gt; Int -&gt; Float -&gt; Float -&gt; String -&gt; User
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;typeを使うと下のように表すことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;type Name = String
type Age = Int
type Height = Float
type Weight = Float
type PhoneNumber = String

data User = User Name Age Height Weight PhoneNumber
    deriving (Show)

name :: User -&gt; Name
name (User name _ _ _ _ ) = name

age :: User -&gt; Age
age (User _ age _ _ _) = age

height :: User -&gt; Height
height (User _ _ height _ _) = height

weight :: User -&gt; Weight
weight (User _ _ _ weight _) = weight

phoneNumber :: User -&gt; PhoneNumber
phoneNumber (User _ _ _ _ phoneNumber) = phoneNumber
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :t User
User :: Name -&gt; Age -&gt; Height -&gt; Weight -&gt; PhoneNumber -&gt; User
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Haskellにはtypeの他にnewtypeもある。&lt;/p&gt;

&lt;h3&gt;newtype&lt;/h3&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;newtype 型構築子 型引数1 型引数2 ... = 値構築子 フィールド
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次のプログラムは &amp;quot;0123&amp;quot; のような数字列を表す型DigitStringを定義したものです。
関数atoiは、数字列を整数に変換する関数です。
引数が数字列であるべきことを強調するために、String型ではなくDigitString型の値を引数に要求します。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;newtype DigitString = DigitString String

atoi :: DigitString -&gt; Int
atoi (DigitString xs) = read xs
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; let n = DigitString &amp;quot;99&amp;quot;
&amp;gt; atoi n
99
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;typeは、既存の型に別名を付けるもので、newtypeは、値構築子数1、フィールド数1の型専用のdata宣言とでも言うべきもので、既存の型をラップした型を与えます。&lt;/p&gt;

&lt;h2&gt;data and type and newtype&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://hnakamur.blogspot.jp/2011/07/haskelldatatypenewtype.html"&gt;Haskellのdataとtypeとnewtypeの違い&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/5889696/difference-between-data-and-newtype-in-haskell"&gt;Difference between &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;newtype&lt;/code&gt; in Haskell&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/18204308/haskell-type-vs-data-constructor"&gt;Haskell Type vs Data Constructor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;型シノニムの多相化&lt;/h1&gt;

&lt;p&gt;前回のおさらい&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;型コンストラクタは型引数を取ることができます。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :i Maybe
data Maybe a = Nothing | Just a
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;値コンストラクタが引数を取って新しい値を生み出すものでしたが、同じように型コンストラクタは型引数を取って新しい型を作るものです。
MaybeにIntを渡すとMaybe Int型が得られますし、MaybeにStringを渡せばMaybe String型が得られます。
こうすることで、&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;data IntMaybe = INothing | IJust Int
data StringMaybe = SNothing | SJust String
data ShapeMaybe = ShNothing | ShJust Shape
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;のように、中身の型ごとに別々の型にする必要がなくなります。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;という感じで、型シノニムも多相化することができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;type AssocList k v = [(k, v)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうすることで、連想リストからキーを検索してくれる関数の型を &lt;code&gt;(Eq k) =&amp;gt; k -&gt; AssocList k v -&gt; Maybe v&lt;/code&gt; と書けるようになります。&lt;/p&gt;

&lt;h1&gt;haskell-jobqueue&lt;/h1&gt;

&lt;p&gt;&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/gree_tech/status/426666332973580288 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- haskell-jobqueue/src/Network/JobQueue/Types.hs
data Next a = Next {
    nextJob :: (Maybe a)
  , nextForks :: [(a, Maybe UTCTime)]
  }

type JobResult a = Either Failure (Next a)

setNextJob :: (Unit a) =&amp;gt; a -&gt; (JobResult a) -&gt; (JobResult a)
setNextJob x (Right next@(Next _ju _xs)) = Right next { nextJob = Just x }
setNextJob _ jr@(Left _) = jr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ジョブとJobResultを引数にして、JobResultのRightだったら次のジョブをセットしたJobResultを返して、LeftだったらそのままJobResultを返す。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;-- haskell-jobqueue/src/Network/JobQueue/JobQueue.hs
type FailureHandleFn a = Alert -&gt; String -&gt; String -&gt; Maybe (Job a) -&gt; IO (Maybe (Job a))
type AfterExecuteHandleFn a = Job a -&gt; IO ()

data (Unit a) =&amp;gt; Settings a = Settings {
    failureHandleFn :: FailureHandleFn a
  , afterExecuteFn :: AfterExecuteHandleFn a
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;長い型をtypeで表したりとかもする。&lt;/p&gt;

&lt;h1&gt;再帰的なデータ構造&lt;/h1&gt;

&lt;p&gt;時間があったら。&lt;/p&gt;

&lt;h1&gt;演算子の定義&lt;/h1&gt;

&lt;p&gt;すごいH本138ページあたりの演算子を定義する話。&lt;/p&gt;

&lt;p&gt;まず、演算子を定義する。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;infixr 5 :-:
data List a = Empty | a :-: (List a ) deriving (Show, Read, Eq, Ord)

infixr 5 ^++
(^++) :: List a -&gt; List a -&gt; List a
Empty ^++ ys ys
(x :-: xs) ^++ ys = x :-: (xs ^++ ys)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして使う。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; let a = 3 :-: 4 :-: 5 :-: Empty
&amp;gt; let b = 6 :-: 7 :-: Empty
&amp;gt; a ^++ b
3 :-: (4 :-: (5 :-: (6 :-: (7 :-: Empty))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://img.tiqav.com/8q.th.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;これを見てもあまり嬉しいと感じられないと思うので、自分で便利そうな演算子を何か一個、作ってみましょう。&lt;/p&gt;

&lt;h3&gt;例. 三項演算子っぽい何か&lt;/h3&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; [x &amp;gt; 5 ? 1 : 2 | x &amp;lt;- [1..10]]
&amp;gt; [2,2,2,2,2,1,1,1,1,1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(これは実現できないので、これっぽいなにかを)&lt;/p&gt;

&lt;p&gt;&lt;a href="http://d.hatena.ne.jp/marony0607/20111205/1323103005"&gt;Haskellの演算子について纏めてみた&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;型クラス&lt;/h1&gt;

&lt;p&gt;型クラスはインターフェイスのようなものです。型クラスは、特定の振る舞い(等値性判定だとか、順序の比較だとか、列挙だとか)を定義します。
定義されたとおりに振る舞うことができる型は、その型クラスのインスタンスである、といいます。&lt;/p&gt;

&lt;h2&gt;型クラスの定義&lt;/h2&gt;

&lt;p&gt;Eq型クラスを例に取りましょう。
Eqは等値性判定ができる(&lt;code&gt;==&lt;/code&gt; や &lt;code&gt;/=&lt;/code&gt;) という関数を定義している)値の型クラスです。
これは標準ライブラリにおけるEqの定義です。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;class Eq a where
  (==) :: a -&gt; a -&gt; Bool
  (/=) :: a -&gt; a -&gt; Bool
  x == y = not (x /= y)
  x /= y = not (x == y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クラスには関数定義と、オプションでデフォルト実装を書くことができます。&lt;/p&gt;

&lt;h2&gt;型クラスのサブクラスの定義&lt;/h2&gt;

&lt;p&gt;別の型クラスのサブクラスである型クラスを作ることもできます。
たとえばNumの型クラス宣言の最初のところは以下のようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;class (Eq a) =&amp;gt; Num a where
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;aはEqの振る舞いを実装している必要もある、というふうになります。&lt;/p&gt;

&lt;h2&gt;型クラス制約&lt;/h2&gt;

&lt;p&gt;リストの要素の和を求める関数sumの型がもし、&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;sum :: [Int] -&gt; Int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では具体的すぎます。かといって、&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;sum :: [a] -&gt; a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では広すぎです。そこで、次のような制約付きの宣言が使われます。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;sum :: Num a =&amp;gt; [a] -&gt; a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sumの型シグネチャ宣言におけるNum aは、型aがNumクラスのインスタンスでなければならないという制約を表します。
この制約は、型クラス制約、あるいは文脈(Context)と呼ばれます。&lt;/p&gt;

&lt;h2&gt;インスタンス化&lt;/h2&gt;

&lt;p&gt;ここで先週作った曜日のデータ型をみてみましょう。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;使える自動導出を全部使って、曜日のデータ型を作ってみましょう。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Eq, Ord, Show, Read, Bounded, Enum)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Eq、Ord、Show、Read、Bounded、Enumを自動導出していましたが、いくつかを手動で導出してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday

instance Eq Day where
  Monday == Monday = True
  Tuesday == Tuesday = True
  Wednesday == Wednesday = True
  Thursday == Thursday = True
  Friday == Friday = True
  Saturday == Saturday = True
  Sunday == Sunday = True
  _ == _ = False

instance Show Day where
  show Monday = &amp;quot;Monday&amp;quot;
  show Tuesday = &amp;quot;Tuesday&amp;quot;
  show Wednesday = &amp;quot;Wednesday&amp;quot;
  show Thursday = &amp;quot;Thursday&amp;quot;
  show Friday = &amp;quot;Friday&amp;quot;
  show Saturday = &amp;quot;Saturday&amp;quot;
  show Sunday = &amp;quot;Sunday&amp;quot;

instance Ord Day where
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; Monday == Sunday
False
&amp;gt; Monday /= Sunday
True
&amp;gt; Friday
Friday
&amp;gt; Monday &amp;lt; Tuesday
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では、まず引数をStringにして返すputs関数を作って、&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;puts :: (Show a) =&amp;gt; a -&gt; String
puts a = show a
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; puts &amp;#39;a&amp;#39;
&amp;quot;&amp;#39;a&amp;#39;&amp;quot;
&amp;gt; puts 1
&amp;quot;1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;それから、IntかCharしか受け取れないように型クラス制約を付けてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; puts &amp;#39;a&amp;#39;
&amp;quot;&amp;#39;a&amp;#39;&amp;quot;
&amp;gt; puts (1 :: Int)
&amp;quot;1&amp;quot;
&amp;gt; puts (1 :: Float)

&amp;lt;interactive&amp;gt;:14:1:
    No instance for (IntOrChar Float)
      arising from a use of `puts&amp;#39;
    Possible fix: add an instance declaration for (IntOrChar Float)
    In the expression: puts (1 :: Float)
    In an equation for `it&amp;#39;: it = puts (1 :: Float)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;多相性&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://yingtai.hatenablog.com/entry/2012/08/17/215648"&gt;Polymorphismまとめ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;パラメータ多相(parametric)&lt;/h3&gt;

&lt;p&gt;Haskellのリストを例に取ると、&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;length :: [a] -&gt; Int
length [] = 0
length (x:xs) = 1 + length xs
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; length [1,2,3]   -- [Int] -&gt; Int
3
&amp;gt; length &amp;quot;foobar&amp;quot;  -- [Char] -&gt; Int
6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この関数のアルゴリズムはリストの中身の型に依存しません。
言い換えれば、length関数は型に関わらず同じ操作をしています。
このようなタイプの多相をパラメータ多相と呼びます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C++のテンプレート&lt;/li&gt;
&lt;li&gt;Javaのジェネリクス&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;アドホック多相(ad-hoc)&lt;/h3&gt;

&lt;p&gt;Haskellでは型クラスにもとづき、型によって振る舞いを変えることをアドホック多相といいます。&lt;/p&gt;

&lt;p&gt;一般的にはアドホック多相にはオーバーロードと型キャストの二つがあります。&lt;/p&gt;

&lt;h4&gt;オーバーロード&lt;/h4&gt;

&lt;p&gt;Cを例に取ると、&lt;/p&gt;

&lt;pre&gt;&lt;code class="c"&gt;n = 1 + 3;        // 整数の加算
r = 1.5 + 2.5;    // 実数の加算
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでの &lt;code&gt;+&lt;/code&gt; 演算子の振る舞いは多相的ですが、実際の加算アルゴリズムは異なります。
この意味で、この2つの演算子が同じ &lt;code&gt;+&lt;/code&gt; であることの必然性はあまりなく、便宜上そうなっているだけ(ad-hoc)にすぎません。&lt;/p&gt;

&lt;h4&gt;型キャスト&lt;/h4&gt;

&lt;pre&gt;&lt;code class="c"&gt;x = 1.5 + 10;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このとき &lt;code&gt;+&lt;/code&gt; の左側は実数型、右側は整数型です。
このとき &lt;code&gt;+&lt;/code&gt; 演算子は見かけの上でだけ多相的です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C++/Javaのメソッドのオーバーロード&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;部分型多相(inclusion, subtyping)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Dog, Cat ∈ Animal&lt;/code&gt; という型の関係があったとき、
Animal型のオブジェクトにsayメソッドが適用できるならば、
Dog型、Cat型のオブジェクトにもsayメソッドが適用できる、といった多相です。&lt;/p&gt;

&lt;p&gt;オブジェクト指向で主に「多態」と呼ばれるタイプの多相。&lt;/p&gt;

&lt;h3&gt;ピンと来ない？&lt;/h3&gt;

&lt;p&gt;アドホック多相は、関数を適用する型を制限するのに対して、パラメータ多相は、具体的な型について言及しないことにより、新しい型に対応できるようにするということらしいです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.nslabs.jp/haskell-poly.rhtml"&gt;Haskellでの多態 (多相)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://chopl.in/blog/2012/11/06/introduction-to-typeclass-with-scala.html"&gt;Scalaで型クラス入門&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;Functor型クラス&lt;/h1&gt;

&lt;p&gt;Functor(関手)は、全体を写せる（map over）ものの型クラスです。
map overと聞いて、リストのmapを思い出しませんか？
あれも何かを写す操作の典型例です。&lt;/p&gt;

&lt;p&gt;Functor型クラスの実装を覗いてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;見てのとおりFunctorは1つの関数 fmap を持っており、デフォルト実装は提供しておりません。
どうやらfmapは、「ある型aから別の型bへの関数」と、「ある型aに適用されたファンクター値」を取り、「別の型bの方に適用されたファンクター値」を返す関数のようです。&lt;/p&gt;

&lt;p&gt;ところで、fmapの型宣言は何かに似ていると思いませんか？&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :t fmap
fmap :: Functor f =&amp;gt; (a -&gt; b) -&gt; f a -&gt; f b
&amp;gt; :t map
map :: (a -&gt; b) -&gt; [a] -&gt; [b]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mapは、「ある型から別の型への関数」と、「ある型のリスト」を取り、「別の型のリスト」を返す関数のようです。&lt;/p&gt;

&lt;p&gt;実は、リストはFunctor型クラスのインスタンスで、mapというのはリスト限定で動作するfmapなのです。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :i []
data [] a = [] | a : [a]        -- Defined in `GHC.Types&amp;#39;
instance Functor [] -- Defined in `GHC.Base&amp;#39;
...

instance Functor [] where
    fmap = map
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src="https://dl.dropboxusercontent.com/u/949822/qiita.com/131125-functors-applicative-and-monads-in-picture/fmap_list.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;リストにとってのfmapはただのmapであるため、2つの関数をリストに使った結果は一致します。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; fmap (*2) [1..3]
[2,4,6]
&amp;gt; map (*2) [1..3]
[2,4,6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Functorになれるのは、箱のような働きをする型です。
リスト以外にも例えばMaybe aがFunctorです。
MaybeはこんなふうにFunctorになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :i Maybe
data Maybe a = Nothing | Just a         -- Defined instance Functor Maybe -- Defined in `Data.Maybe&amp;#39;
...

instance Functor Maybe where
  fmap f (Just x) = Just (f x)
  fmap f Nothing = Nothing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fmapの実装はいたってシンプルです。
もし2つ目の引数が値の入ったJustだったら関数をJustの中身に適用して、Nothingだったら、Nothingを返します。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://yogsototh.github.io/Category-Theory-Presentation/categories/img/mp/boxfunctor.png" width="400"&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; fmap (++ &amp;quot; HEY GUYS IM INSIDE THE JUST&amp;quot;) (Just &amp;quot;Something serious.&amp;quot;)
Just &amp;quot;Something serious. HEY GUYS IM INSIDE THE JUST&amp;quot;
&amp;gt; fmap (++ &amp;quot; HEY GUYS IM INSIDE THE JUST&amp;quot;) Nothing
Nothing
&amp;gt; fmap (*2) (Just 200)
Just 400
&amp;gt; fmap (*2) Nothing
Nothing
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://qiita.com/suin/items/0255f0637921dcdfe83b"&gt;箱で考えるFunctor、ApplicativeそしてMonad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://ja.wikibooks.org/wiki/Haskell/%E5%9C%8F%E8%AB%96"&gt;Haskell/圏論&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://d.hatena.ne.jp/enakai00/20130912/1378970253"&gt;Functorを例として、圏論とHaskellの関係を分かりやすく説明してみるテスト&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;型の種類&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;[a]&lt;/code&gt; や &lt;code&gt;Maybe a&lt;/code&gt; のような型コンストラクタは、他の型を引数に取って具体型になります。
この振る舞いは、関数が値を引数に取って値を生み出すのとよく似ています。
それに、関数と同じく型コンストラクタも部分適用できます。
ここでは、型が型コンストラクタに適用される様子を形式的に定義してみます。&lt;/p&gt;

&lt;p&gt;3、&amp;quot;YEAH!&amp;quot;、takeWhileといった値（関数も受け取ったり渡したりできる値です）は、それぞれ固有の値を持っています。
型とは、値について何らかの推測をするための小さなラベルです。
そして型にも小さなラベルがついています。
その名は種類（kind）。種類は、「型の型」のようなものです。&lt;/p&gt;

&lt;p&gt;ghciの &lt;code&gt;:kind&lt;/code&gt; コマンドを使って、型の種類をみてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :k Int
Int :: *
&amp;gt; :k []
[] :: * -&gt; *
&amp;gt; :k Maybe
Maybe :: * -&gt; *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;*&lt;/code&gt; (スター)は、具体型を表す記号です。
&lt;code&gt;[]&lt;/code&gt; や &lt;code&gt;Maybe&lt;/code&gt; は1つの具体型(例えばInt)を取って具体型(例えばMaybe Int)を返す型コンストラクタであることが分かります。&lt;/p&gt;

&lt;p&gt;型コンストラクタに型引数を与えて、どんな種類の型ができるか調べてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :k [Char]
[Char] :: *
&amp;gt; :k Maybe Int
Maybe Int :: *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;型引数を与えると、具体型になりました。
型は値のラベルであり、種類は型のラベルである、という対応関係があるわけです。&lt;/p&gt;

&lt;p&gt;改めてFunctorの定義を見直すと、型変数fは1つの具体型を取って具体型を生み出す型として使われていることが見て取れます。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数の型宣言で値の型として使われていることから &lt;code&gt;f a&lt;/code&gt; や &lt;code&gt;f b&lt;/code&gt; は具体型でなければならないことが分かります。
Functorになるには &lt;code&gt;* -&gt; *&lt;/code&gt; という種類を持つ必要があるということが分かります。&lt;/p&gt;

&lt;h1&gt;今後のスケジュール&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://sugoihaskell.github.io/"&gt;sugoihaskell.github.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
</feed>
