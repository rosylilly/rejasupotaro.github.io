<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rejasupoem</title>
  <subtitle>deliver value to customers continuously or die;</subtitle>
  <id>http://rejasupotaro.github.io/</id>
  <link href="http://rejasupotaro.github.io/"/>
  <link href="http://rejasupotaro.github.io/feed.xml" rel="self"/>
  <updated>2014-02-11T00:00:00+09:00</updated>
  <author>
    <name>rejasupotaro</name>
  </author>
  <entry>
    <title>How to build a career through github activities</title>
    <link rel="alternate" href="http://rejasupotaro.github.io/2014/02/11/36.html"/>
    <id>http://rejasupotaro.github.io/2014/02/11/36.html</id>
    <published>2014-02-11T00:00:00+09:00</published>
    <updated>2014-02-12T14:15:38+09:00</updated>
    <author>
      <name>rejasupotaro</name>
    </author>
    <content type="html">&lt;script async class="speakerdeck-embed" data-id="d07deda0755701312eb91a125ab0a9e4" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"&gt;&lt;/script&gt;

&lt;p&gt;&lt;a href="https://github.com/potatotips/potatotips/wiki/potatotips-4"&gt;potatotips-4&lt;/a&gt; で自分が作ったライブラリをどうやって使ってもらうかという話をしました。
元ネタはninjinkunさんの&lt;a href="http://www.slideshare.net/ninjinkun/i-os-30692824"&gt;GitHub活動を通して個人のキャリアを積みつつ仕事の成果を出す方法&lt;/a&gt;です。
持ち時間が5分だったので、時間の都合上端折った箇所を補足します。&lt;/p&gt;

&lt;h1&gt;1. 試しやすくする&lt;/h1&gt;

&lt;h3&gt;サンプルアプリを付ける　&lt;/h3&gt;

&lt;p&gt;サンプルがあるとどういう動きをするのか実際にさわって分かるというのと、それ自体がドキュメントとしての役割を持つので、ライブラリ導入のハードルを下げると思います。
それと、ライブラリを開発しているときも一旦どこかにデプロイして〜とかしなくてもよくなるので、開発スピードが上がります。&lt;/p&gt;

&lt;h1&gt;2. 組み込みやすくする&lt;/h1&gt;

&lt;p&gt;いざ自分のプロジェクトにライブラリを入れようと思ったときに、インストールの仕方が書いてないとアッアッとなります。
そこで開発者が離れていってしまうのはもったいないので、インストール手順は書いた方がいいです。&lt;/p&gt;

&lt;h3&gt;githubにrepositoryとして使う&lt;/h3&gt;

&lt;p&gt;maven-metadata.xmlとファイルの実体さえあえば、どこでもmavenリポジトリにすることができます。
gradleの例ですが、以下のような記述を &lt;code&gt;projectDir/build.gradle&lt;/code&gt; に追加して、&lt;/p&gt;

&lt;pre&gt;&lt;code class="groovy"&gt;apply plugin: &amp;#39;android-library&amp;#39;
apply plugin: &amp;#39;maven&amp;#39;

uploadArchives {
    repositories {
        mavenDeployer {
            repository url: &amp;quot;file://${projectDir}/repository&amp;quot;
            pom.groupId = &amp;#39;rejasupotaro&amp;#39;
            pom.artifactId = &amp;#39;my-library&amp;#39;
            pom.version = &amp;#39;0.0.1&amp;#39;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コマンドを実行すると、&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ gradle uploadArchives
$ tree repository
repository
└── rejasupotaro
    └── my-library
        ├── 0.0.1
        │   ├── my-library-0.0.1.aar
        │   ├── my-library-0.0.1.aar.md5
        │   ├── my-library-0.0.1.aar.sha1
        │   ├── my-library-0.0.1.pom
        │   ├── my-library-0.0.1.pom.md5
        │   └── my-library-0.0.1.pom.sha1
        ├── maven-metadata.xml
        ├── maven-metadata.xml.md5
        └── maven-metadata.xml.sha1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このようになります。
これをコミットしてプッシュします。&lt;/p&gt;

&lt;h3&gt;github上のrepositoryからdependencyを解決する&lt;/h3&gt;

&lt;p&gt;githubのファイルには &lt;code&gt;raw.github.com&lt;/code&gt; でアクセスできるので、repositoriesにgithubのurlを指定して、dependenciesに追加すれば、ライブラリを使うことができるようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class="groovy"&gt;repositories {
    ...
    maven { url &amp;#39;https://raw.github.com/rejasupotaro/MyLibrary/master/library/repository&amp;#39; }
}

dependencies {
    ...
    compile &amp;#39;rejasupotaro:my-library:0.0.1&amp;#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;ローカルでjarにする&lt;/h2&gt;

&lt;p&gt;リソースもいらないし手元で、jarに出来ればよいという場合には、以下のようにすればいいと思います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apply plugin: &amp;#39;java&amp;#39;

group = &amp;#39;rejasupotaro&amp;#39;
archivesBaseName = &amp;#39;my-library&amp;#39;
version = &amp;#39;0.0.1&amp;#39;

sourceSets {
    main {
        java {
            srcDir &amp;#39;src/main/java&amp;#39;
        }
    }
}

dependencies {
    compile fileTree(dir: &amp;#39;libs&amp;#39;, include: &amp;#39;*.jar&amp;#39;)
}

task sourcesJar(type: Jar) {
    classifier = &amp;#39;sources&amp;#39;
    from sourceSets.main.allSource
}

artifacts {
    archives sourcesJar
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$ gradle jar&lt;/code&gt; を実行すると &lt;code&gt;src/main/java&lt;/code&gt; 以下のclassファイルとManifestのarchive(jar)が作成されます。&lt;/p&gt;

&lt;p&gt;pluginが他のプラグインとぶつかるときは、環境変数で切り替えたりしています。
たとえばjarを作るときはリリース時なので &lt;code&gt;$ gradle jar -Penv=release&lt;/code&gt; みたいな。&lt;/p&gt;

&lt;h1&gt;3. 品質を高める&lt;/h1&gt;

&lt;p&gt;テストをどう書くか、という話はここではしませんが、少なくともテストのないライブラリは積極的に使おうという気にはならないですよね。
テストに加えて、CIが通ったバッチがREADMEについてると、なお安心感があります。&lt;/p&gt;

&lt;p&gt;どのCIサービスを使うかという話ですが、好みがあると思いますが、僕は一応Wercker推しです。
以下、非常に偏った比較です。&lt;/p&gt;

&lt;h3&gt;Wercker&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;何も書かなくてもデフォルトのビルドファイルを適用してくれる&lt;/li&gt;
&lt;li&gt;あらかじめビルド環境(Box)が用意されている&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/wercker/box-android"&gt;wercker / box-android&lt;/a&gt;が公開されてる&lt;/li&gt;
&lt;li&gt;submoduleを自動で取ってきてくれる&lt;/li&gt;
&lt;li&gt;あと何秒みたいなのが表示されたり、グラフィカルなBuild Statsがあったり、UIが洗練されている&lt;/li&gt;
&lt;li&gt;ビルドがTravisと比べて速い&lt;/li&gt;
&lt;li&gt;ログはリアルタイムに更新されない&lt;/li&gt;
&lt;li&gt;デプロイまで面倒を見てくれる&lt;/li&gt;
&lt;li&gt;まだβ版なので今後どうなるかは分からない&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Circle CI&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ちょっと洗練されたTravis(イメージ)&lt;/li&gt;
&lt;li&gt;結構ビジネスって使ってるって聞きます&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Travis&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;個人の開発者とか、OSSで一番よく使われている&lt;/li&gt;
&lt;li&gt;最初は設定が面倒だけど、一度設定すれば設定ファイルをコピペでいける&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;サーバーのセットアップ&lt;/h3&gt;

&lt;p&gt;社内のAndroidのビルド環境のセットアップを丹精込めて手作業で行なってきたけど、最近物忘れが激しくて &lt;code&gt;android…update…filter…?no-ui…???&lt;/code&gt; みたいにコマンドがうろ覚え状態ということもあり、CIサーバーのセットアップを自動化できないかと思って流行りのchefとかfabricとかserverspecとかを使ってみたけど、&lt;a href="https://github.com/embarkmobile/android-sdk-installer"&gt;android-sdk-installer&lt;/a&gt;を使うというところに落ち着きました。&lt;/p&gt;

&lt;p&gt;これのいいところは、Travisを使っている人は分かると思いますが、毎回 &lt;code&gt;wait_for_emulator&lt;/code&gt; をコピペしていたのが、ツールの中に入ってるのが良かったです。&lt;/p&gt;

&lt;h1&gt;4. 表現を工夫する&lt;/h1&gt;

&lt;p&gt;UIのライブラリはgifアニメがあるだけで印象がだいぶ変わります。
あとライセンスがREADMEに書いてあるものも、僕的にポイント高いです。&lt;/p&gt;

&lt;p&gt;&lt;img height="200" src="https://github-camo.global.ssl.fastly.net/d20ac6fb1cb14db4b69ab5e48ebd609aab1f6831/687474703a2f2f6f70656e61706869642e6769746875622e636f6d2f696d616765732f666c6970766965772d686f72697a6f6e74616c2d64656d6f2e676966"&gt;
&lt;img height="200" src="http://gifzo.net/jTEl4YmZqD.gif"&gt;
&lt;img height="200" src="http://gifzo.net/BWvNCrQFYfF.gif"&gt;
&lt;img height="200" src="http://gifzo.net/68NrYQW2tB.gif"&gt;
&lt;img height="200" src="http://gifzo.net/lSwyh4fg6P.gif"&gt;
&lt;img height="200" src="http://gifzo.net/OKyqq1D9yD.gif"&gt;&lt;/p&gt;

&lt;p&gt;みたいな。&lt;/p&gt;

&lt;h1&gt;5. 広報&lt;/h1&gt;

&lt;p&gt;READMEはインストール方法とか、ライブラリの使い方とかしか書けないけど、ブログならどういう問題があって、どういうアプローチで解決したかみたいな背景も書けるので、そういうのを知ると使ってみようかなっていう気になるし、それに拡散できるのでよいです。&lt;/p&gt;

&lt;h1&gt;おわりに&lt;/h1&gt;

&lt;p&gt;&lt;img src="https://dl.dropboxusercontent.com/u/54255753/blog/201402/activities.png" alt=""&gt;
&lt;img src="https://dl.dropboxusercontent.com/u/54255753/blog/201402/aizen.png" alt=""&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>KinMozaView is updated!!</title>
    <link rel="alternate" href="http://rejasupotaro.github.io/2014/02/09/35.html"/>
    <id>http://rejasupotaro.github.io/2014/02/09/35.html</id>
    <published>2014-02-09T00:00:00+09:00</published>
    <updated>2014-02-12T14:14:50+09:00</updated>
    <author>
      <name>rejasupotaro</name>
    </author>
    <content type="html">&lt;h2&gt;きんモザビューワーをアップデートしました！&lt;/h2&gt;

&lt;p&gt;&lt;img src="https://github.com/rejasupotaro/KinMozaViewer/blob/master/screenshot.png?raw=true" alt=""&gt;&lt;/p&gt;

&lt;h2&gt;主な変更点は2点！&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;自動再生機能を追加しました！&lt;/li&gt;
&lt;li&gt;再生中に画面をスリープしないようにしました！&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://github.com/rejasupotaro/KinMozaViewer/blob/master/screenshot.png?raw=true" alt=""&gt;&lt;/p&gt;

&lt;p&gt;ダウンロード(というかビルド)は&lt;a href="https://github.com/rejasupotaro/KinMozaViewer"&gt;GitHub&lt;/a&gt;からどうぞ！&lt;/p&gt;

&lt;p&gt;&lt;a href="http://rejasupotaro.github.io/2013/10/31/8.html"&gt;リリースしたときに書いたブログ&lt;/a&gt;はリンクを貼っただけだったので、ちょっと技術的な話をします。&lt;/p&gt;

&lt;h2&gt;gifの表示について&lt;/h2&gt;

&lt;p&gt;表示しているgifは&lt;a href="http://mogashi.hateblo.jp/entry/2013/09/24/000619"&gt;APIで取得している&lt;/a&gt;のですが、Androidでgifを表示するにはかなり頑張らないといけないので、WebViewで表示するようにしました。&lt;/p&gt;

&lt;p&gt;assetsにテンプレートを置いておいて、APIで取得したURLと動的に取得した画面幅を組み込んで、loadDataWithBaseURLでコンテンツをWebViewに流しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;String imageUrl = UrlUtils.buildAliceUrl(ep, no);
String content = mTemplate.compile(imageUrl);
loadDataWithBaseURL(&amp;quot;&amp;quot;, content, &amp;quot;text/html&amp;quot;, HTTP.UTF_8, null);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;自動再生について&lt;/h2&gt;

&lt;p&gt;一定時間おきにタスクを実行するコードをよく書く気がしたので、汎用的なクラスを作りました。
コンストラクタにRunnableとインターバル値を入れます。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public class PeriodicTimerTask {

    private Handler mHandler = new Handler();

    private Runnable mTask;

    private int mTaskIntervalMs;

    private TimerTask mTimerTask;

    private Timer mTimer;

    private TimerTask newTimerTask() {
        return new TimerTask() {
            @Override
            public void run() {
                mHandler.post(mTask);
            }
        };
    }

    private Timer newTimer() {
        return new Timer(true);
    }

    public PeriodicTimerTask(Runnable task, int taskIntervalMs) {
        mTask = task;
        mTaskIntervalMs = taskIntervalMs;
    }

    public void start() {
        if (mTimer == null) {
            mTimerTask = newTimerTask();
            mTimer = newTimer();
            mTimer.schedule(mTimerTask, 0, mTaskIntervalMs);
        }
    }

    public void stop() {
        if (mTimer != null) {
            mTimer.cancel();
            mTimer = null;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;たとえばこのアプリでは、自動再生モードがオンのとき、SeekBarを一定時間おきに動かしています。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public class MediaTimerTask extends PeriodicTimerTask {

    private static final int TASK_INTERVAL_MS = 500;

    private static final int PROGRESS_INCREMENT = 10;

    public MediaTimerTask(final SeekBar seekBar) {
        super(new Runnable() {
            @Override
            public void run() {
                if (seekBar == null) {
                    return;
                }

                int progress = seekBar.getProgress();
                if (progress &amp;gt;= seekBar.getMax()) {
                    progress = 0;
                } else {
                    progress += PROGRESS_INCREMENT;
                }
                seekBar.setProgress(progress);
            }
        }, TASK_INTERVAL_MS);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SeekBarでは進捗(Progress)に変化があったときに、進捗値から何章のどこら辺かを計算して、そのパラメータを付けてAPIを叩いて、画面を更新します。&lt;/p&gt;

&lt;h2&gt;アプリをスリープさせない&lt;/h2&gt;

&lt;p&gt;MainActivityのonCreate相当のところで下のような処理をしています。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;private void keepScreenOn() {
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;アイコンを作る&lt;/h2&gt;

&lt;p&gt;アイコンを作るのに&lt;a href="http://android-ui-utils.googlecode.com/hg/asset-studio/dist/index.html"&gt;Android Asset Studio&lt;/a&gt;を使おうとするんだけど、Android Asset Studioだと角丸ができないので、調べたら&lt;a href="http://www.gieson.com/Library/projects/utilities/icon_slayer/"&gt;Icon Slayer&lt;/a&gt;っていうのが出てきて、それを使っています。&lt;/p&gt;

&lt;p&gt;&lt;img src="https://dl.dropboxusercontent.com/u/54255753/blog/201402/icon_generator.png" alt=""&gt;&lt;/p&gt;

&lt;h2&gt;効果的な使用方法&lt;/h2&gt;

&lt;p&gt;手元のAndroid搭載プロジェクタにこのアプリを入れて、部屋を暗くしてコードを書いてる後ろでエンドレスで再生し続けます。&lt;/p&gt;

&lt;p&gt;&lt;img src="https://dl.dropboxusercontent.com/u/54255753/blog/201402/projector.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;6畳に物が散乱している狭い部屋を、生ぬるいくらいの温度にして、プロジェクタとノートPCの光だけが部屋を照らしている中、寝落ちするまでコードを書く。
よく分からないけどこの生活が癖になってしまって、とにかく昼間眠い。&lt;/p&gt;

&lt;p&gt;&lt;img src="https://github.com/rejasupotaro/KinMozaViewer/blob/master/screenshot.png?raw=true" alt=""&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>ListViewのデータのbindはこうする2014</title>
    <link rel="alternate" href="http://rejasupotaro.github.io/2014/02/06/34.html"/>
    <id>http://rejasupotaro.github.io/2014/02/06/34.html</id>
    <published>2014-02-06T00:00:00+09:00</published>
    <updated>2014-02-12T14:14:50+09:00</updated>
    <author>
      <name>rejasupotaro</name>
    </author>
    <content type="html">&lt;p&gt;基本の割に初心者にとって使うのにハードルが高いview、ListView。
ネット調べると色んなパターンで書かれた例が出てくると思います。&lt;/p&gt;

&lt;p&gt;何も知らずにAndroid 1.6とかの時代に書かれたような出どころが不明なサンプルコードをコピペしてうまくいかなくて心が折れるみたいなことを防ぐために、インターネットに出回っているサンプルコードをパターン化して列挙しました。パターン1が一番良くなくて、パターン3あるいはパターン4にするといいと思います。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://www.geek.com/wp-content/uploads/2009/10/settings.JPG" width="120"&gt;&lt;/p&gt;

&lt;p&gt;インターネットで調べててAndroid 1.6とか2系の葬式UIが出てきたら、それは昔に書かれたものでそっと閉じたほうがいいです。&lt;/p&gt;

&lt;h1&gt;Adapterとは&lt;/h1&gt;

&lt;p&gt;AdapterはviewとDataSourceの橋渡しをするものです。&lt;/p&gt;

&lt;p&gt;&lt;a href="http://www.edureka.in/blog/what-are-adapters-in-android/"&gt;&lt;img src="http://www.edureka.in/blog/wp-content/uploads/2013/03/adapters.jpg" alt=""&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;private void setupListView(List&amp;lt;User&amp;gt; userList) {
    UserAdapter adapter = new UserAdapter(context, resourceId, userList);
    // Viewに直接データを渡すのではなく、Adapterを渡す
    mListView.setAdapter(adapter);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、viewは生成のコストが高いので、AndroidフレームワークにViewを使い回すしくみがあります。&lt;/p&gt;

&lt;p&gt;&lt;a href="http://android.amberfog.com/?p=296"&gt;&lt;img src="http://android.amberfog.com/wp-content/uploads/2010/02/listview_recycler.jpg" alt=""&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;1. viewがgetされるたびに生成&lt;/h1&gt;

&lt;p&gt;viewが描画位置に入るとgetViewが呼ばれて、viewを生成して返すとそれが描画されます。
recycle poolの存在を知らないと、その都度生成してしまってListViewの描画がガタガタになります(僕も昔やってました)。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public class SampleAdapter1 extends ArrayAdapter&amp;lt;User&amp;gt; {

    public SampleAdapter1(Context context, int resource, List&amp;lt;User&amp;gt; objects) {
        super(context, resource, objects);
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        View view = View.inflate(getContext(), R.layout.list_item_user, parent);

        User user = getItem(position);

        TextView numberTextView = (TextView) view.findViewById(R.id.number);
        numberTextView.setText(String.valueOf(position));

        ImageView userThumbnailImageView = (ImageView) view.findViewById(R.id.user_thumbnail);
        new SetBitmapFromNetworkTask(userThumbnailImageView).execute(user.getThumbnailUrl());

        TextView userNameTextView = (TextView) view.findViewById(R.id.user_name);
        userNameTextView.setText(user.getName());

        TextView userBiographyTextView = (TextView) view.findViewById(R.id.user_biography);
        userBiographyTextView.setText(user.getBiography());

        return view;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;2. convertViewがnullのときにだけ生成&lt;/h1&gt;

&lt;p&gt;recycle poolからreuseされたviewはconvertViewに入ってくるので、convertViewがnullじゃなければ、中身だけを書き換えて再利用するようにしたコードが以下です。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public class SampleAdapter2 extends ArrayAdapter&amp;lt;User&amp;gt; {

    public SampleAdapter2(Context context, int resource, List&amp;lt;User&amp;gt; objects) {
        super(context, resource, objects);
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        if (convertView == null) {
            convertView = View.inflate(getContext(), R.layout.list_item_user, parent);
        }

        User user = getItem(position);

        TextView numberTextView = (TextView) convertView.findViewById(R.id.number);
        numberTextView.setText(String.valueOf(position));

        ImageView userThumbnailImageView = (ImageView) convertView.findViewById(R.id.user_thumbnail);
        new SetBitmapFromNetworkTask(userThumbnailImageView).execute(user.getThumbnailUrl());

        TextView userNameTextView = (TextView) convertView.findViewById(R.id.user_name);
        userNameTextView.setText(user.getName());

        TextView userBiographyTextView = (TextView) convertView.findViewById(R.id.user_biography);
        userBiographyTextView.setText(user.getBiography());

        return convertView;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;3. convertViewがnullのときにだけ生成 + ViewHolderにviewをキャッシュ&lt;/h1&gt;

&lt;p&gt;convertViewが使いまわされたリストの一行のviewなのですが、その中のviewを毎回探索するのは無駄なので、ViewHolderクラスを作ってキャッシュさせます。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public class SampleAdapter3 extends ArrayAdapter&amp;lt;User&amp;gt; {

    private static class ViewHolder {
        TextView numberTextView;
        ImageView userThumbnailImageView;
        TextView userNameTextView;
        TextView userBiographyTextView;

        public ViewHolder(View view) {
            this.numberTextView = (TextView) view.findViewById(R.id.number);
            this.userThumbnailImageView = (ImageView) view.findViewById(R.id.user_thumbnail);
            this.userNameTextView = (TextView) view.findViewById(R.id.user_name);
            this.userBiographyTextView = (TextView) view.findViewById(R.id.user_biography);
        }
    }

    public SampleAdapter3(Context context, int resource, List&amp;lt;User&amp;gt; objects) {
        super(context, resource, objects);
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        ViewHolder holder;
        if (convertView == null) {
            convertView = View.inflate(getContext(), R.layout.list_item_user, parent);
            holder = new ViewHolder(convertView);
            convertView.setTag(holder);
        } else {
            holder = (ViewHolder) convertView.getTag();
        }

        User user = getItem(position);

        holder.numberTextView.setText(String.valueOf(position));
        new SetBitmapFromNetworkTask(holder.userThumbnailImageView).execute(user.getThumbnailUrl());
        holder.userNameTextView.setText(user.getName());
        holder.userBiographyTextView.setText(user.getBiography());

        return convertView;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;4. BindableAdapterを使う&lt;/h1&gt;

&lt;p&gt;「convertViewがnullのときは新しくviewを生成して、nullじゃなかったらViewに値をセットして」をコードに落としこむとこうなる感じです。
IDEのデフォルト機能でViewHolder以外のコードを生成できるので、コンストラクタの引数で迷わないし、型パラメータのおかげでitemをそのままViewにbindできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public class SampleAdapter4 extends BindableAdapter&amp;lt;User&amp;gt; {

    public SampleAdapter4(Context context, List&amp;lt;User&amp;gt; episodeList) {
        super(context, episodeList);
    }

    private static class ViewHolder {
        private TextView numberTextView;
        private ImageView userThumbnailImageView;
        private TextView userNameTextView;
        private TextView userBiographyTextView;

        ViewHolder(View view) {
            numberTextView = (TextView) view.findViewById(R.id.number);
            userThumbnailImageView = (ImageView) view.findViewById(R.id.user_thumbnail);
            userNameTextView = (TextView) view.findViewById(R.id.user_name);
            userBiographyTextView = (TextView) view.findViewById(R.id.user_biography);
        }
    }

    @Override
    public View newView(LayoutInflater inflater, int position, ViewGroup container) {
        View view =  inflater.inflate(R.layout.list_item_user, container, false);
        ViewHolder holder = new ViewHolder(view);
        view.setTag(holder);
        return view;
    }

    @Override
    public void bindView(User item, int position, View view) {
        ViewHolder holder = (ViewHolder) view.getTag();

        holder.numberTextView.setText(String.valueOf(position));
        new SetBitmapFromNetworkTask(holder.userThumbnailImageView).execute(item.getThumbnailUrl());
        holder.userNameTextView.setText(item.getName());
        holder.userBiographyTextView.setText(item.getBiography());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="java"&gt;public abstract class BindableAdapter&amp;lt;T&amp;gt; extends ArrayAdapter&amp;lt;T&amp;gt; {

    private LayoutInflater mInflater;

    public BindableAdapter(Context context, List&amp;lt;T&amp;gt; episodeList) {
        super(context, 0, episodeList);
        setup(context);
    }

    private void setup(Context context) {
        mInflater = LayoutInflater.from(context);
    }

    @Override
    public final View getView(int position, View view, ViewGroup container) {
        if (view == null) {
            view = newView(mInflater, position, container);
            if (view == null) {
                throw new IllegalStateException(&amp;quot;newView result must not be null.&amp;quot;);
            }
        }
        bindView(getItem(position), position, view);
        return view;
    }

    public abstract View newView(LayoutInflater inflater, int position, ViewGroup container);

    public abstract void bindView(T item, int position, View view);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でもViewHolderを手で書いたり、pluginで生成するのもあれなんですよね、 &lt;strong&gt;まさか来週の&lt;a href="https://github.com/potatotips/potatotips/wiki/potatotips-4"&gt;potatotips&lt;/a&gt;で@__gfx__さんがgradleでxmlからジャバコードを自動生成するわけじゃあるまいし(前フリ)&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>第7章 型や型クラスを自分で作ろう 後編</title>
    <link rel="alternate" href="http://rejasupotaro.github.io/2014/02/02/33.html"/>
    <id>http://rejasupotaro.github.io/2014/02/02/33.html</id>
    <published>2014-02-02T00:00:00+09:00</published>
    <updated>2014-02-12T14:14:50+09:00</updated>
    <author>
      <name>rejasupotaro</name>
    </author>
    <content type="html">&lt;h1&gt;前回やったこと&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;データ型の定義&lt;/li&gt;
&lt;li&gt;データ型のエクスポート&lt;/li&gt;
&lt;li&gt;レコード構文&lt;/li&gt;
&lt;li&gt;多相型と型引数&lt;/li&gt;
&lt;li&gt;インスタンスの自動導出&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/knjname/status/427053066030833664 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/nobkz/status/428789457068646401 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/nida_001/status/428789602015387648 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/tail_y/status/428822946719604736 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/VoQn/status/429091683783806976 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1&gt;今回やること&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;型シノニム

&lt;ul&gt;
&lt;li&gt;型シノニムの多相化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;再帰的なデータ構造&lt;/li&gt;
&lt;li&gt;演算子の定義&lt;/li&gt;
&lt;li&gt;型クラス

&lt;ul&gt;
&lt;li&gt;型クラスの定義&lt;/li&gt;
&lt;li&gt;型クラスのサブクラス&lt;/li&gt;
&lt;li&gt;型クラス制約&lt;/li&gt;
&lt;li&gt;多相性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Functor型クラス&lt;/li&gt;
&lt;li&gt;型の種類&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;型と新しい型(type and newtype)&lt;/h1&gt;

&lt;h2&gt;type&lt;/h2&gt;

&lt;p&gt;何章か前に出てきましたが &lt;code&gt;[Char]&lt;/code&gt; と &lt;code&gt;String&lt;/code&gt; は同値で、交換可能です。
ghciで &lt;code&gt;:i String&lt;/code&gt; としてみてください。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :i String
type String = [Char]    -- Defined in `GHC.Base&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;type 型構築子 型引数1 型引数2 ... = 元の型
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;typeは型のシノニムが定義されているのであって、新しい型が作られている訳ではありません。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ちょっと復習ですが、名前、年齢、身長、体重、電話番号を持つUserを表すデータ型は、&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;data User = User String Int Float Float String
    deriving (Show)

name :: User -&gt; String
name (User name _ _ _ _ ) = name

age :: User -&gt; Int
age (User _ age _ _ _) = age

height :: User -&gt; Float
height (User _ _ height _ _) = height

weight :: User -&gt; Float
weight (User _ _ _ weight _) = weight

phoneNumber :: User -&gt; String
phoneNumber (User _ _ _ _ phoneNumber) = phoneNumber
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このようになって、値構築子(値コンストラクタ)は関数なので &lt;code&gt;:type&lt;/code&gt; で型シグネチャを見ることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :t User
User :: String -&gt; Int -&gt; Float -&gt; Float -&gt; String -&gt; User
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;型シグネチャだけ見ても何を渡せばいいのか分からないということで、レコード構文もやりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;data User = User { name :: String
                 , age :: Int
                 , height :: Float
                 , weight :: Float
                 , phoneNumber :: String } deriving (Show)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :t User
User :: String -&gt; Int -&gt; Float -&gt; Float -&gt; String -&gt; User
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;typeを使うと下のように表すことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;type Name = String
type Age = Int
type Height = Float
type Weight = Float
type PhoneNumber = String

data User = User Name Age Height Weight PhoneNumber
    deriving (Show)

name :: User -&gt; Name
name (User name _ _ _ _ ) = name

age :: User -&gt; Age
age (User _ age _ _ _) = age

height :: User -&gt; Height
height (User _ _ height _ _) = height

weight :: User -&gt; Weight
weight (User _ _ _ weight _) = weight

phoneNumber :: User -&gt; PhoneNumber
phoneNumber (User _ _ _ _ phoneNumber) = phoneNumber
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :t User
User :: Name -&gt; Age -&gt; Height -&gt; Weight -&gt; PhoneNumber -&gt; User
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Haskellにはtypeの他にnewtypeもある。&lt;/p&gt;

&lt;h3&gt;newtype&lt;/h3&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;newtype 型構築子 型引数1 型引数2 ... = 値構築子 フィールド
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次のプログラムは &amp;quot;0123&amp;quot; のような数字列を表す型DigitStringを定義したものです。
関数atoiは、数字列を整数に変換する関数です。
引数が数字列であるべきことを強調するために、String型ではなくDigitString型の値を引数に要求します。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;newtype DigitString = DigitString String

atoi :: DigitString -&gt; Int
atoi (DigitString xs) = read xs
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; let n = DigitString &amp;quot;99&amp;quot;
&amp;gt; atoi n
99
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;typeは、既存の型に別名を付けるもので、newtypeは、値構築子数1、フィールド数1の型専用のdata宣言とでも言うべきもので、既存の型をラップした型を与えます。&lt;/p&gt;

&lt;h2&gt;data and type and newtype&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://hnakamur.blogspot.jp/2011/07/haskelldatatypenewtype.html"&gt;Haskellのdataとtypeとnewtypeの違い&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/5889696/difference-between-data-and-newtype-in-haskell"&gt;Difference between &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;newtype&lt;/code&gt; in Haskell&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/18204308/haskell-type-vs-data-constructor"&gt;Haskell Type vs Data Constructor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;型シノニムの多相化&lt;/h1&gt;

&lt;p&gt;前回のおさらい&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;型コンストラクタは型引数を取ることができます。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :i Maybe
data Maybe a = Nothing | Just a
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;値コンストラクタが引数を取って新しい値を生み出すものでしたが、同じように型コンストラクタは型引数を取って新しい型を作るものです。
MaybeにIntを渡すとMaybe Int型が得られますし、MaybeにStringを渡せばMaybe String型が得られます。
こうすることで、&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;data IntMaybe = INothing | IJust Int
data StringMaybe = SNothing | SJust String
data ShapeMaybe = ShNothing | ShJust Shape
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;のように、中身の型ごとに別々の型にする必要がなくなります。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;という感じで、型シノニムも多相化することができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;type AssocList k v = [(k, v)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうすることで、連想リストからキーを検索してくれる関数の型を &lt;code&gt;(Eq k) =&amp;gt; k -&gt; AssocList k v -&gt; Maybe v&lt;/code&gt; と書けるようになります。&lt;/p&gt;

&lt;h1&gt;haskell-jobqueue&lt;/h1&gt;

&lt;p&gt;&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/gree_tech/status/426666332973580288 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- haskell-jobqueue/src/Network/JobQueue/Types.hs
data Next a = Next {
    nextJob :: (Maybe a)
  , nextForks :: [(a, Maybe UTCTime)]
  }

type JobResult a = Either Failure (Next a)

setNextJob :: (Unit a) =&amp;gt; a -&gt; (JobResult a) -&gt; (JobResult a)
setNextJob x (Right next@(Next _ju _xs)) = Right next { nextJob = Just x }
setNextJob _ jr@(Left _) = jr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ジョブとJobResultを引数にして、JobResultのRightだったら次のジョブをセットしたJobResultを返して、LeftだったらそのままJobResultを返す。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;-- haskell-jobqueue/src/Network/JobQueue/JobQueue.hs
type FailureHandleFn a = Alert -&gt; String -&gt; String -&gt; Maybe (Job a) -&gt; IO (Maybe (Job a))
type AfterExecuteHandleFn a = Job a -&gt; IO ()

data (Unit a) =&amp;gt; Settings a = Settings {
    failureHandleFn :: FailureHandleFn a
  , afterExecuteFn :: AfterExecuteHandleFn a
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;長い型をtypeで表したりとかもする。&lt;/p&gt;

&lt;h1&gt;再帰的なデータ構造&lt;/h1&gt;

&lt;p&gt;時間があったら。&lt;/p&gt;

&lt;h1&gt;演算子の定義&lt;/h1&gt;

&lt;p&gt;すごいH本138ページあたりの演算子を定義する話。&lt;/p&gt;

&lt;p&gt;まず、演算子を定義する。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;infixr 5 :-:
data List a = Empty | a :-: (List a ) deriving (Show, Read, Eq, Ord)

infixr 5 ^++
(^++) :: List a -&gt; List a -&gt; List a
Empty ^++ ys ys
(x :-: xs) ^++ ys = x :-: (xs ^++ ys)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして使う。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; let a = 3 :-: 4 :-: 5 :-: Empty
&amp;gt; let b = 6 :-: 7 :-: Empty
&amp;gt; a ^++ b
3 :-: (4 :-: (5 :-: (6 :-: (7 :-: Empty))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://img.tiqav.com/8q.th.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;これを見てもあまり嬉しいと感じられないと思うので、自分で便利そうな演算子を何か一個、作ってみましょう。&lt;/p&gt;

&lt;h3&gt;例. 三項演算子っぽい何か&lt;/h3&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; [x &amp;gt; 5 ? 1 : 2 | x &amp;lt;- [1..10]]
&amp;gt; [2,2,2,2,2,1,1,1,1,1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(これは実現できないので、これっぽいなにかを)&lt;/p&gt;

&lt;p&gt;&lt;a href="http://d.hatena.ne.jp/marony0607/20111205/1323103005"&gt;Haskellの演算子について纏めてみた&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;型クラス&lt;/h1&gt;

&lt;p&gt;型クラスはインターフェイスのようなものです。型クラスは、特定の振る舞い(等値性判定だとか、順序の比較だとか、列挙だとか)を定義します。
定義されたとおりに振る舞うことができる型は、その型クラスのインスタンスである、といいます。&lt;/p&gt;

&lt;h2&gt;型クラスの定義&lt;/h2&gt;

&lt;p&gt;Eq型クラスを例に取りましょう。
Eqは等値性判定ができる(&lt;code&gt;==&lt;/code&gt; や &lt;code&gt;/=&lt;/code&gt;) という関数を定義している)値の型クラスです。
これは標準ライブラリにおけるEqの定義です。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;class Eq a where
  (==) :: a -&gt; a -&gt; Bool
  (/=) :: a -&gt; a -&gt; Bool
  x == y = not (x /= y)
  x /= y = not (x == y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クラスには関数定義と、オプションでデフォルト実装を書くことができます。&lt;/p&gt;

&lt;h2&gt;型クラスのサブクラスの定義&lt;/h2&gt;

&lt;p&gt;別の型クラスのサブクラスである型クラスを作ることもできます。
たとえばNumの型クラス宣言の最初のところは以下のようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;class (Eq a) =&amp;gt; Num a where
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;aはEqの振る舞いを実装している必要もある、というふうになります。&lt;/p&gt;

&lt;h2&gt;型クラス制約&lt;/h2&gt;

&lt;p&gt;リストの要素の和を求める関数sumの型がもし、&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;sum :: [Int] -&gt; Int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では具体的すぎます。かといって、&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;sum :: [a] -&gt; a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では広すぎです。そこで、次のような制約付きの宣言が使われます。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;sum :: Num a =&amp;gt; [a] -&gt; a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sumの型シグネチャ宣言におけるNum aは、型aがNumクラスのインスタンスでなければならないという制約を表します。
この制約は、型クラス制約、あるいは文脈(Context)と呼ばれます。&lt;/p&gt;

&lt;h2&gt;インスタンス化&lt;/h2&gt;

&lt;p&gt;ここで先週作った曜日のデータ型をみてみましょう。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;使える自動導出を全部使って、曜日のデータ型を作ってみましょう。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Eq, Ord, Show, Read, Bounded, Enum)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Eq、Ord、Show、Read、Bounded、Enumを自動導出していましたが、いくつかを手動で導出してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday

instance Eq Day where
  Monday == Monday = True
  Tuesday == Tuesday = True
  Wednesday == Wednesday = True
  Thursday == Thursday = True
  Friday == Friday = True
  Saturday == Saturday = True
  Sunday == Sunday = True
  _ == _ = False

instance Show Day where
  show Monday = &amp;quot;Monday&amp;quot;
  show Tuesday = &amp;quot;Tuesday&amp;quot;
  show Wednesday = &amp;quot;Wednesday&amp;quot;
  show Thursday = &amp;quot;Thursday&amp;quot;
  show Friday = &amp;quot;Friday&amp;quot;
  show Saturday = &amp;quot;Saturday&amp;quot;
  show Sunday = &amp;quot;Sunday&amp;quot;

instance Ord Day where
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; Monday == Sunday
False
&amp;gt; Monday /= Sunday
True
&amp;gt; Friday
Friday
&amp;gt; Monday &amp;lt; Tuesday
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では、まず引数をStringにして返すputs関数を作って、&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;puts :: (Show a) =&amp;gt; a -&gt; String
puts a = show a
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; puts &amp;#39;a&amp;#39;
&amp;quot;&amp;#39;a&amp;#39;&amp;quot;
&amp;gt; puts 1
&amp;quot;1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;それから、IntかCharしか受け取れないように型クラス制約を付けてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; puts &amp;#39;a&amp;#39;
&amp;quot;&amp;#39;a&amp;#39;&amp;quot;
&amp;gt; puts (1 :: Int)
&amp;quot;1&amp;quot;
&amp;gt; puts (1 :: Float)

&amp;lt;interactive&amp;gt;:14:1:
    No instance for (IntOrChar Float)
      arising from a use of `puts&amp;#39;
    Possible fix: add an instance declaration for (IntOrChar Float)
    In the expression: puts (1 :: Float)
    In an equation for `it&amp;#39;: it = puts (1 :: Float)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;多相性&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://yingtai.hatenablog.com/entry/2012/08/17/215648"&gt;Polymorphismまとめ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;パラメータ多相(parametric)&lt;/h3&gt;

&lt;p&gt;Haskellのリストを例に取ると、&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;length :: [a] -&gt; Int
length [] = 0
length (x:xs) = 1 + length xs
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; length [1,2,3]   -- [Int] -&gt; Int
3
&amp;gt; length &amp;quot;foobar&amp;quot;  -- [Char] -&gt; Int
6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この関数のアルゴリズムはリストの中身の型に依存しません。
言い換えれば、length関数は型に関わらず同じ操作をしています。
このようなタイプの多相をパラメータ多相と呼びます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C++のテンプレート&lt;/li&gt;
&lt;li&gt;Javaのジェネリクス&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;アドホック多相(ad-hoc)&lt;/h3&gt;

&lt;p&gt;Haskellでは型クラスにもとづき、型によって振る舞いを変えることをアドホック多相といいます。&lt;/p&gt;

&lt;p&gt;一般的にはアドホック多相にはオーバーロードと型キャストの二つがあります。&lt;/p&gt;

&lt;h4&gt;オーバーロード&lt;/h4&gt;

&lt;p&gt;Cを例に取ると、&lt;/p&gt;

&lt;pre&gt;&lt;code class="c"&gt;n = 1 + 3;        // 整数の加算
r = 1.5 + 2.5;    // 実数の加算
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでの &lt;code&gt;+&lt;/code&gt; 演算子の振る舞いは多相的ですが、実際の加算アルゴリズムは異なります。
この意味で、この2つの演算子が同じ &lt;code&gt;+&lt;/code&gt; であることの必然性はあまりなく、便宜上そうなっているだけ(ad-hoc)にすぎません。&lt;/p&gt;

&lt;h4&gt;型キャスト&lt;/h4&gt;

&lt;pre&gt;&lt;code class="c"&gt;x = 1.5 + 10;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このとき &lt;code&gt;+&lt;/code&gt; の左側は実数型、右側は整数型です。
このとき &lt;code&gt;+&lt;/code&gt; 演算子は見かけの上でだけ多相的です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C++/Javaのメソッドのオーバーロード&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;部分型多相(inclusion, subtyping)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Dog, Cat ∈ Animal&lt;/code&gt; という型の関係があったとき、
Animal型のオブジェクトにsayメソッドが適用できるならば、
Dog型、Cat型のオブジェクトにもsayメソッドが適用できる、といった多相です。&lt;/p&gt;

&lt;p&gt;オブジェクト指向で主に「多態」と呼ばれるタイプの多相。&lt;/p&gt;

&lt;h3&gt;ピンと来ない？&lt;/h3&gt;

&lt;p&gt;アドホック多相は、関数を適用する型を制限するのに対して、パラメータ多相は、具体的な型について言及しないことにより、新しい型に対応できるようにするということらしいです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.nslabs.jp/haskell-poly.rhtml"&gt;Haskellでの多態 (多相)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://chopl.in/blog/2012/11/06/introduction-to-typeclass-with-scala.html"&gt;Scalaで型クラス入門&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;Functor型クラス&lt;/h1&gt;

&lt;p&gt;Functor(関手)は、全体を写せる（map over）ものの型クラスです。
map overと聞いて、リストのmapを思い出しませんか？
あれも何かを写す操作の典型例です。&lt;/p&gt;

&lt;p&gt;Functor型クラスの実装を覗いてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;見てのとおりFunctorは1つの関数 fmap を持っており、デフォルト実装は提供しておりません。
どうやらfmapは、「ある型aから別の型bへの関数」と、「ある型aに適用されたファンクター値」を取り、「別の型bの方に適用されたファンクター値」を返す関数のようです。&lt;/p&gt;

&lt;p&gt;ところで、fmapの型宣言は何かに似ていると思いませんか？&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :t fmap
fmap :: Functor f =&amp;gt; (a -&gt; b) -&gt; f a -&gt; f b
&amp;gt; :t map
map :: (a -&gt; b) -&gt; [a] -&gt; [b]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mapは、「ある型から別の型への関数」と、「ある型のリスト」を取り、「別の型のリスト」を返す関数のようです。&lt;/p&gt;

&lt;p&gt;実は、リストはFunctor型クラスのインスタンスで、mapというのはリスト限定で動作するfmapなのです。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :i []
data [] a = [] | a : [a]        -- Defined in `GHC.Types&amp;#39;
instance Functor [] -- Defined in `GHC.Base&amp;#39;
...

instance Functor [] where
    fmap = map
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src="https://dl.dropboxusercontent.com/u/949822/qiita.com/131125-functors-applicative-and-monads-in-picture/fmap_list.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;リストにとってのfmapはただのmapであるため、2つの関数をリストに使った結果は一致します。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; fmap (*2) [1..3]
[2,4,6]
&amp;gt; map (*2) [1..3]
[2,4,6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Functorになれるのは、箱のような働きをする型です。
リスト以外にも例えばMaybe aがFunctorです。
MaybeはこんなふうにFunctorになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :i Maybe
data Maybe a = Nothing | Just a         -- Defined instance Functor Maybe -- Defined in `Data.Maybe&amp;#39;
...

instance Functor Maybe where
  fmap f (Just x) = Just (f x)
  fmap f Nothing = Nothing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fmapの実装はいたってシンプルです。
もし2つ目の引数が値の入ったJustだったら関数をJustの中身に適用して、Nothingだったら、Nothingを返します。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://yogsototh.github.io/Category-Theory-Presentation/categories/img/mp/boxfunctor.png" width="400"&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; fmap (++ &amp;quot; HEY GUYS IM INSIDE THE JUST&amp;quot;) (Just &amp;quot;Something serious.&amp;quot;)
Just &amp;quot;Something serious. HEY GUYS IM INSIDE THE JUST&amp;quot;
&amp;gt; fmap (++ &amp;quot; HEY GUYS IM INSIDE THE JUST&amp;quot;) Nothing
Nothing
&amp;gt; fmap (*2) (Just 200)
Just 400
&amp;gt; fmap (*2) Nothing
Nothing
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://qiita.com/suin/items/0255f0637921dcdfe83b"&gt;箱で考えるFunctor、ApplicativeそしてMonad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://ja.wikibooks.org/wiki/Haskell/%E5%9C%8F%E8%AB%96"&gt;Haskell/圏論&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://d.hatena.ne.jp/enakai00/20130912/1378970253"&gt;Functorを例として、圏論とHaskellの関係を分かりやすく説明してみるテスト&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;型の種類&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;[a]&lt;/code&gt; や &lt;code&gt;Maybe a&lt;/code&gt; のような型コンストラクタは、他の型を引数に取って具体型になります。
この振る舞いは、関数が値を引数に取って値を生み出すのとよく似ています。
それに、関数と同じく型コンストラクタも部分適用できます。
ここでは、型が型コンストラクタに適用される様子を形式的に定義してみます。&lt;/p&gt;

&lt;p&gt;3、&amp;quot;YEAH!&amp;quot;、takeWhileといった値（関数も受け取ったり渡したりできる値です）は、それぞれ固有の値を持っています。
型とは、値について何らかの推測をするための小さなラベルです。
そして型にも小さなラベルがついています。
その名は種類（kind）。種類は、「型の型」のようなものです。&lt;/p&gt;

&lt;p&gt;ghciの &lt;code&gt;:kind&lt;/code&gt; コマンドを使って、型の種類をみてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :k Int
Int :: *
&amp;gt; :k []
[] :: * -&gt; *
&amp;gt; :k Maybe
Maybe :: * -&gt; *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;*&lt;/code&gt; (スター)は、具体型を表す記号です。
&lt;code&gt;[]&lt;/code&gt; や &lt;code&gt;Maybe&lt;/code&gt; は1つの具体型(例えばInt)を取って具体型(例えばMaybe Int)を返す型コンストラクタであることが分かります。&lt;/p&gt;

&lt;p&gt;型コンストラクタに型引数を与えて、どんな種類の型ができるか調べてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :k [Char]
[Char] :: *
&amp;gt; :k Maybe Int
Maybe Int :: *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;型引数を与えると、具体型になりました。
型は値のラベルであり、種類は型のラベルである、という対応関係があるわけです。&lt;/p&gt;

&lt;p&gt;改めてFunctorの定義を見直すと、型変数fは1つの具体型を取って具体型を生み出す型として使われていることが見て取れます。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数の型宣言で値の型として使われていることから &lt;code&gt;f a&lt;/code&gt; や &lt;code&gt;f b&lt;/code&gt; は具体型でなければならないことが分かります。
Functorになるには &lt;code&gt;* -&gt; *&lt;/code&gt; という種類を持つ必要があるということが分かります。&lt;/p&gt;

&lt;h1&gt;今後のスケジュール&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://sugoihaskell.github.io/"&gt;sugoihaskell.github.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>2014/01/30</title>
    <link rel="alternate" href="http://rejasupotaro.github.io/2014/01/30/32.html"/>
    <id>http://rejasupotaro.github.io/2014/01/30/32.html</id>
    <published>2014-01-30T00:00:00+09:00</published>
    <updated>2014-02-12T14:14:50+09:00</updated>
    <author>
      <name>rejasupotaro</name>
    </author>
    <content type="html">&lt;h3&gt;〜今日の夕方〜&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;「僕らも&lt;a href="http://square.github.io/"&gt;Square&lt;/a&gt;みたいに積極的にライブラリ公開していきたいですね」&lt;br&gt;
「ですねー。maven centralにライブラリを上げたことありますか？」&lt;br&gt;
「ないですね。社内ライブラリはS3で管理しているので、mavenリポジトリはそっちに上げたことはありますが」&lt;br&gt;
「おっ、そうなんですか。じゃあmaven centralにも上げましょうよ！」&lt;br&gt;
「maven centralって面倒なんですよね。あっ、じゃあどっちが先にデプロイできるか競争しましょう！」  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/rejasupotaro/status/428818040407326721 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;今になってみるとこのとき &lt;a href="https://twitter.com/__gfx__"&gt;@&lt;strong&gt;gfx&lt;/strong&gt;&lt;/a&gt; さん、苦笑いしていたように思える。&lt;/p&gt;

&lt;h3&gt;家に帰ってやり方を調べる僕&lt;/h3&gt;

&lt;p&gt;&lt;a href="http://d.hatena.ne.jp/int128/20130409/1365434513"&gt;GradleでMaven Central Repositoryに成果物をリリースする&lt;/a&gt; とか &lt;a href="http://felipecsl.com/blog/2013/12/06/publishing-an-android-library-to-maven-central/"&gt;Publishing an Android Library to Maven Central With Gradle&lt;/a&gt; とかを読みました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;!!!Wait for your issue to be “Resolved”, that may take up to 2 business days (!!!)!!!
!!!That is really piece of cake compared to all this Java mess!!!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とてもためになりました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/rejasupotaro/status/428874546712567808 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/rejasupotaro/status/428883261347995649 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;若者には厳しいシステムでした。&lt;a href="https://twitter.com/rejasupotaro/status/428006626071552000"&gt;拝承&lt;/a&gt;。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>進捗、例外、画面の切り替え</title>
    <link rel="alternate" href="http://rejasupotaro.github.io/2014/01/30/31.html"/>
    <id>http://rejasupotaro.github.io/2014/01/30/31.html</id>
    <published>2014-01-30T00:00:00+09:00</published>
    <updated>2014-02-12T14:14:50+09:00</updated>
    <author>
      <name>rejasupotaro</name>
    </author>
    <content type="html">&lt;p&gt;&lt;img src="https://dl.dropboxusercontent.com/u/54255753/blog/201401/state.png" width="600"&gt;&lt;/p&gt;

&lt;p&gt;ネットワークからデータを取ってくるときにProgressBarを回して、正常に読み込みたらコンテンツを、読み込めなかったらエラーを表示したいときどうしますか？&lt;/p&gt;

&lt;h1&gt;愚直な方法&lt;/h1&gt;

&lt;p&gt;全体をFrameLayoutにしてコンテンツの上にProgressView、ErrorViewになるように重ねる。&lt;/p&gt;

&lt;pre&gt;&lt;code class="xml"&gt;&amp;lt;FrameLayout
        android:background=&amp;quot;@android:color/holo_blue_light&amp;quot;
        android:layout_width=&amp;quot;match_parent&amp;quot;
        android:layout_height=&amp;quot;match_parent&amp;quot;
        &amp;gt;
    &amp;lt;LinearLayout
            android:orientation=&amp;quot;vertical&amp;quot;
            android:layout_gravity=&amp;quot;center&amp;quot;
            android:layout_width=&amp;quot;wrap_content&amp;quot;
            android:layout_height=&amp;quot;wrap_content&amp;quot;
            &amp;gt;
        &amp;lt;ImageView
                android:src=&amp;quot;@drawable/droid&amp;quot;
                android:layout_gravity=&amp;quot;center&amp;quot;
                android:layout_width=&amp;quot;wrap_content&amp;quot;
                android:layout_height=&amp;quot;wrap_content&amp;quot;
                /&amp;gt;
        &amp;lt;TextView
                android:text=&amp;quot;content&amp;quot;
                android:textSize=&amp;quot;@dimen/default_text_size&amp;quot;
                android:textColor=&amp;quot;@color/default_text_color&amp;quot;
                android:layout_gravity=&amp;quot;center&amp;quot;
                android:layout_width=&amp;quot;wrap_content&amp;quot;
                android:layout_height=&amp;quot;wrap_content&amp;quot;
                /&amp;gt;
    &amp;lt;/LinearLayout&amp;gt;
    &lt;!-- 以下を元のレイアウトに追加 --&gt;
    &amp;lt;include
        android:id=&amp;quot;@+id/progress_view&amp;quot;
        layout=&amp;quot;@layout/progress_view&amp;quot;
        android:visibility=&amp;quot;gone&amp;quot;
        /&amp;gt;
    &amp;lt;include
        android:id=&amp;quot;@+id/error_view&amp;quot;
        layout=&amp;quot;@layout/error_view&amp;quot;
        android:visibility=&amp;quot;gone&amp;quot;
        /&amp;gt;
&amp;lt;/FrameLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;続いてジャバ。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;@InjectView(R.id.progress_view) private View mProgressView;
@InjectView(R.id.error_view) private View mErrorView;

private void requestRssFeed() {
    mProgressView.show();
    mErrorView.hide();

    mRssFeedClient.request(new RssFeedClient.EpisodeClientResponseHandler() {
        @Override public void onSuccess(List&amp;lt;Episode&amp;gt; episodeList) {
            BusProvider.getInstance().post(new LoadEpisodeListCompleteEvent(episodeList));
            mProgressView.hide();
            mErrorView.hide();
        }

        @Override public void onFailure() {
            ToastUtils.show(getActivity(), &amp;quot;An error occurred while requesting rss feed.&amp;quot;);
            mProgressView.hide();
            mErrorView.show();
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;悪くはないけど、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;元のレイアウトをあまり変更したくない&lt;/li&gt;
&lt;li&gt;ProgressViewとErrorViewを別々に扱うので不安になる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;って書きながら思った。&lt;/p&gt;

&lt;h1&gt;もうちょっとスマートに表現&lt;/h1&gt;

&lt;p&gt;全体を囲むViewGroupがステートを持ってた方がいいかなと思って以下のように実装。&lt;/p&gt;

&lt;pre&gt;&lt;code class="xml"&gt;&lt;!-- FrameLayoutの代わりにStateFrameLayout(作った)を使う --&gt;
&amp;lt;rejasupotaro.sample.views.StateFrameLayout
        android:id=&amp;quot;@+id/state_frame_layout&amp;quot;
        android:background=&amp;quot;@android:color/holo_blue_light&amp;quot;
        android:layout_width=&amp;quot;match_parent&amp;quot;
        android:layout_height=&amp;quot;match_parent&amp;quot;
        &amp;gt;
    &amp;lt;LinearLayout
            android:orientation=&amp;quot;vertical&amp;quot;
            android:layout_gravity=&amp;quot;center&amp;quot;
            android:layout_width=&amp;quot;wrap_content&amp;quot;
            android:layout_height=&amp;quot;wrap_content&amp;quot;
            &amp;gt;
        &amp;lt;ImageView
                android:src=&amp;quot;@drawable/droid&amp;quot;
                android:layout_gravity=&amp;quot;center&amp;quot;
                android:layout_width=&amp;quot;wrap_content&amp;quot;
                android:layout_height=&amp;quot;wrap_content&amp;quot;
                /&amp;gt;
        &amp;lt;TextView
                android:text=&amp;quot;content&amp;quot;
                android:textSize=&amp;quot;@dimen/default_text_size&amp;quot;
                android:textColor=&amp;quot;@color/default_text_color&amp;quot;
                android:layout_gravity=&amp;quot;center&amp;quot;
                android:layout_width=&amp;quot;wrap_content&amp;quot;
                android:layout_height=&amp;quot;wrap_content&amp;quot;
                /&amp;gt;
    &amp;lt;/LinearLayout&amp;gt;
&amp;lt;/rejasupotaro.sample.views.StateFrameLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;続いてジャバ。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;@InjectView(R.id.state_frame_layout) private StateFrameLayout mStateFrameLayout;

private void requestRssFeed() {
    mStateFrameLayout.showProgress();

    mRssFeedClient.request(new RssFeedClient.EpisodeClientResponseHandler() {
        @Override public void onSuccess(List&amp;lt;Episode&amp;gt; episodeList) {
            BusProvider.getInstance().post(new LoadEpisodeListCompleteEvent(episodeList));
            mStateFrameLayout.showContent();
        }

        @Override public void onFailure() {
            ToastUtils.show(getActivity(), &amp;quot;An error occurred while requesting rss feed.&amp;quot;);
            mStateFrameLayout.showError();
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;元のレイアウトに変更はほぼ必要ない&lt;/li&gt;
&lt;li&gt;ステートの管理が少し楽になる&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;確認してみる&lt;/h3&gt;

&lt;p&gt;とりあえず2秒ごとにステートを変更してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;handler.postDelayed(new Runnable() {
        @Override public void run() {
            if (mStateFrameLayout.isStateProgress()) {
                mStateFrameLayout.showError();
            } else if (mStateFrameLayout.isStateError()) {
                mStateFrameLayout.showContent();
            } else {
                mStateFrameLayout.showProgress();
            }
            handler.postDelayed(this, TASK_INTERVAL_MILLIS);
        }
}, TASK_INTERVAL_MILLIS);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://gifzo.net/BMfi6eoXjgf.gif" width="200"&gt;&lt;/p&gt;

&lt;p&gt;ちゃんと動いてるっぽい。&lt;/p&gt;

&lt;h1&gt;StateFrameLayout&lt;/h1&gt;

&lt;p&gt;ContentViewがinflateされたタイミングでProgressViewとErrorViewを生成してセットし直してるだけです(なので動的にビューを追加しようとしたらちょっと変更が必要です)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class StateFrameLayout extends FrameLayout {

    private View mContentView;
    private View mProgressView;
    private View mErrorView;
    private State mState = State.CONTENT;

    public static enum State {
        CONTENT,
        PROGRESS,
        ERORR;
    }

    public State getState() {
        return mState;
    }

    public boolean isStateContent() {
        return (mState == State.CONTENT);
    }

    public boolean isStateProgress() {
        return (mState == State.PROGRESS);
    }

    public boolean isStateError() {
        return (mState == State.ERORR);
    }

    public StateFrameLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override public void onFinishInflate() {
        setupView();
    }

    private void setupView() {
        List&amp;lt;View&amp;gt; children = getAllChildren();
        removeAllViews();

        mContentView = inflateContentView(children);
        mProgressView = View.inflate(getContext(), R.layout.progress_view, null);
        mErrorView = View.inflate(getContext(), R.layout.error_view, null);

        addView(mContentView);
        addView(mProgressView);
        addView(mErrorView);
    }

    private List&amp;lt;View&amp;gt; getAllChildren() {
        List&amp;lt;View&amp;gt; children = new ArrayList&amp;lt;&amp;gt;();
        int childCount = getChildCount();
        for (int i = 0; i &amp;lt; childCount; i++) {
            children.add(getChildAt(i));
        }

        return children;
    }

    private View inflateContentView(List&amp;lt;View&amp;gt; viewList) {
        FrameLayout frameLayout = new FrameLayout(getContext());
        for (View view : viewList) {
            frameLayout.addView(view);
        }
        return frameLayout;
    }

    public void showProgress() {
        mContentView.setVisibility(View.GONE);
        mProgressView.setVisibility(View.VISIBLE);
        mErrorView.setVisibility(View.GONE);

        mState = State.PROGRESS;
    }

    public void showError() {
        mContentView.setVisibility(View.GONE);
        mProgressView.setVisibility(View.GONE);
        mErrorView.setVisibility(View.VISIBLE);

        mState = State.ERORR;
    }

    public void showContent() {
        mContentView.setVisibility(View.VISIBLE);
        mProgressView.setVisibility(View.GONE);
        mErrorView.setVisibility(View.GONE);

        mState = State.CONTENT;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ProgressViewとかErrorViewのレイアウトIDとか、エラー文言とかはXMLに書けると再利用性高まると思う。
属性は &lt;code&gt;namespace + attribute&lt;/code&gt; で取れる。たとえば &lt;code&gt;android:text&lt;/code&gt; ならこんな感じで。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// LayoutUtils.java とかにどうぞ
private static final String NAME_SPACE_ANDROID = &amp;quot;http://schemas.android.com/apk/res/android&amp;quot;;

public static final String getStringFromAttribute(Context context, AttributeSet attrs) {
    if (context == null || attrs == null) return &amp;quot;&amp;quot;;

    int textId = attrs.getAttributeResourceValue(NAME_SPACE_ANDROID, &amp;quot;text&amp;quot;, -1);
    if (textId == -1) {
        context.getString(textId)
    } else {
        return &amp;quot;&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとビューのデバッグするのにJakeWharton神の&lt;a href="https://github.com/JakeWharton/scalpel"&gt;Scalpel&lt;/a&gt;便利。&lt;/p&gt;

&lt;p&gt;&lt;img src="https://dl.dropboxusercontent.com/u/54255753/blog/201401/scalpel.png" width="200"&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://github.com/JakeWharton/scalpel/raw/master/images/sample.gif" width="200"&gt;&lt;/p&gt;
</content>
  </entry>
</feed>
