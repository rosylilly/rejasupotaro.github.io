<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rejasupoem</title>
  <subtitle>continue to deliver value to customers or die;</subtitle>
  <id>http://rejasupotaro.github.io/</id>
  <link href="http://rejasupotaro.github.io/"/>
  <link href="http://rejasupotaro.github.io/feed.xml" rel="self"/>
  <updated>2014-02-09T00:00:00+09:00</updated>
  <author>
    <name>rejasupotaro</name>
  </author>
  <entry>
    <title>KinMozaView is updated!!</title>
    <link rel="alternate" href="http://rejasupotaro.github.io/2014/02/09/35.html"/>
    <id>http://rejasupotaro.github.io/2014/02/09/35.html</id>
    <published>2014-02-09T00:00:00+09:00</published>
    <updated>2014-02-09T02:35:29+09:00</updated>
    <author>
      <name>rejasupotaro</name>
    </author>
    <content type="html">&lt;h2&gt;きんモザビューワーをアップデートしました！&lt;/h2&gt;

&lt;p&gt;&lt;img src="https://github.com/rejasupotaro/KinMozaViewer/blob/master/screenshot.png?raw=true" alt=""&gt;&lt;/p&gt;

&lt;h2&gt;主な変更点は2点！&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;自動再生機能を追加しました！&lt;/li&gt;
&lt;li&gt;再生中に画面をスリープしないようにしました！&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://github.com/rejasupotaro/KinMozaViewer/blob/master/screenshot.png?raw=true" alt=""&gt;&lt;/p&gt;

&lt;p&gt;ダウンロード(というかビルド)は&lt;a href="https://github.com/rejasupotaro/KinMozaViewer"&gt;GitHub&lt;/a&gt;からどうぞ！&lt;/p&gt;

&lt;p&gt;&lt;a href="http://rejasupotaro.github.io/2013/10/31/8.html"&gt;リリースしたときに書いたブログ&lt;/a&gt;はリンクを貼っただけだったので、ちょっと技術的な話をします。&lt;/p&gt;

&lt;h2&gt;gifの表示について&lt;/h2&gt;

&lt;p&gt;表示しているgifは&lt;a href="http://mogashi.hateblo.jp/entry/2013/09/24/000619"&gt;APIで取得している&lt;/a&gt;のですが、Androidでgifを表示するにはかなり頑張らないといけないので、WebViewで表示するようにしました。&lt;/p&gt;

&lt;p&gt;assetsにテンプレートを置いておいて、APIで取得したURLと動的に取得した画面幅を組み込んで、loadDataWithBaseURLでコンテンツをWebViewに流しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;String imageUrl = UrlUtils.buildAliceUrl(ep, no);
String content = mTemplate.compile(imageUrl);
loadDataWithBaseURL(&amp;quot;&amp;quot;, content, &amp;quot;text/html&amp;quot;, HTTP.UTF_8, null);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;自動再生について&lt;/h2&gt;

&lt;p&gt;一定時間おきにタスクを実行するコードをよく書く気がしたので、汎用的なクラスを作りました。
コンストラクタにRunnableとインターバル値を入れます。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public class PeriodicTimerTask {

    private Handler mHandler = new Handler();

    private Runnable mTask;

    private int mTaskIntervalMs;

    private TimerTask mTimerTask;

    private Timer mTimer;

    private TimerTask newTimerTask() {
        return new TimerTask() {
            @Override
            public void run() {
                mHandler.post(mTask);
            }
        };
    }

    private Timer newTimer() {
        return new Timer(true);
    }

    public PeriodicTimerTask(Runnable task, int taskIntervalMs) {
        mTask = task;
        mTaskIntervalMs = taskIntervalMs;
    }

    public void start() {
        if (mTimer == null) {
            mTimerTask = newTimerTask();
            mTimer = newTimer();
            mTimer.schedule(mTimerTask, 0, mTaskIntervalMs);
        }
    }

    public void stop() {
        if (mTimer != null) {
            mTimer.cancel();
            mTimer = null;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;たとえばこのアプリでは、自動再生モードがオンのとき、SeekBarを一定時間おきに動かしています。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public class MediaTimerTask extends PeriodicTimerTask {

    private static final int TASK_INTERVAL_MS = 500;

    private static final int PROGRESS_INCREMENT = 10;

    public MediaTimerTask(final SeekBar seekBar) {
        super(new Runnable() {
            @Override
            public void run() {
                if (seekBar == null) {
                    return;
                }

                int progress = seekBar.getProgress();
                if (progress &amp;gt;= seekBar.getMax()) {
                    progress = 0;
                } else {
                    progress += PROGRESS_INCREMENT;
                }
                seekBar.setProgress(progress);
            }
        }, TASK_INTERVAL_MS);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SeekBarでは進捗(Progress)に変化があったときに、進捗値から何章のどこら辺かを計算して、そのパラメータを付けてAPIを叩いて、画面を更新します。&lt;/p&gt;

&lt;h2&gt;アプリをスリープさせない&lt;/h2&gt;

&lt;p&gt;MainActivityのonCreate相当のところで下のような処理をしています。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;private void keepScreenOn() {
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;アイコンを作る&lt;/h2&gt;

&lt;p&gt;アイコンを作るのに&lt;a href="http://android-ui-utils.googlecode.com/hg/asset-studio/dist/index.html"&gt;Android Asset Studio&lt;/a&gt;を使おうとするんだけど、Android Asset Studioだと角丸ができないので、調べたら&lt;a href="http://www.gieson.com/Library/projects/utilities/icon_slayer/"&gt;Icon Slayer&lt;/a&gt;っていうのが出てきて、それを使っています。&lt;/p&gt;

&lt;p&gt;&lt;img src="https://dl.dropboxusercontent.com/u/54255753/blog/201402/icon_generator.png" alt=""&gt;&lt;/p&gt;

&lt;h2&gt;効果的な使用方法&lt;/h2&gt;

&lt;p&gt;手元のAndroid搭載プロジェクタにこのアプリを入れて、部屋を暗くしてコードを書いてる後ろでエンドレスで再生し続けます。&lt;/p&gt;

&lt;p&gt;&lt;img src="https://dl.dropboxusercontent.com/u/54255753/blog/201402/projector.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;6畳に物が散乱している狭い部屋を、生ぬるいくらいの温度にして、プロジェクタとノートPCの光だけが部屋を照らしている中、寝落ちするまでコードを書く。
よく分からないけどこの生活が癖になってしまって、とにかく昼間眠い。&lt;/p&gt;

&lt;p&gt;&lt;img src="https://github.com/rejasupotaro/KinMozaViewer/blob/master/screenshot.png?raw=true" alt=""&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>ListViewのデータのbindはこうする2014</title>
    <link rel="alternate" href="http://rejasupotaro.github.io/2014/02/06/34.html"/>
    <id>http://rejasupotaro.github.io/2014/02/06/34.html</id>
    <published>2014-02-06T00:00:00+09:00</published>
    <updated>2014-02-09T01:15:20+09:00</updated>
    <author>
      <name>rejasupotaro</name>
    </author>
    <content type="html">&lt;p&gt;基本の割に初心者にとって使うのにハードルが高いview、ListView。
ネット調べると色んなパターンで書かれた例が出てくると思います。&lt;/p&gt;

&lt;p&gt;何も知らずにAndroid 1.6とかの時代に書かれたような出どころが不明なサンプルコードをコピペしてうまくいかなくて心が折れるみたいなことを防ぐために、インターネットに出回っているサンプルコードをパターン化して列挙しました。パターン1が一番良くなくて、パターン3あるいはパターン4にするといいと思います。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://www.geek.com/wp-content/uploads/2009/10/settings.JPG" width="120"&gt;&lt;/p&gt;

&lt;p&gt;インターネットで調べててAndroid 1.6とか2系の葬式UIが出てきたら、それは昔に書かれたものでそっと閉じたほうがいいです。&lt;/p&gt;

&lt;h1&gt;Adapterとは&lt;/h1&gt;

&lt;p&gt;AdapterはviewとDataSourceの橋渡しをするものです。&lt;/p&gt;

&lt;p&gt;&lt;a href="http://www.edureka.in/blog/what-are-adapters-in-android/"&gt;&lt;img src="http://www.edureka.in/blog/wp-content/uploads/2013/03/adapters.jpg" alt=""&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;private void setupListView(List&amp;lt;User&amp;gt; userList) {
    UserAdapter adapter = new UserAdapter(context, resourceId, userList);
    // Viewに直接データを渡すのではなく、Adapterを渡す
    mListView.setAdapter(adapter);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、viewは生成のコストが高いので、AndroidフレームワークにViewを使い回すしくみがあります。&lt;/p&gt;

&lt;p&gt;&lt;a href="http://android.amberfog.com/?p=296"&gt;&lt;img src="http://android.amberfog.com/wp-content/uploads/2010/02/listview_recycler.jpg" alt=""&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;1. viewがgetされるたびに生成&lt;/h1&gt;

&lt;p&gt;viewが描画位置に入るとgetViewが呼ばれて、viewを生成して返すとそれが描画されます。
recycle poolの存在を知らないと、その都度生成してしまってListViewの描画がガタガタになります(僕も昔やってました)。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public class SampleAdapter1 extends ArrayAdapter&amp;lt;User&amp;gt; {

    public SampleAdapter1(Context context, int resource, List&amp;lt;User&amp;gt; objects) {
        super(context, resource, objects);
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        View view = View.inflate(getContext(), R.layout.list_item_user, parent);

        User user = getItem(position);

        TextView numberTextView = (TextView) view.findViewById(R.id.number);
        numberTextView.setText(String.valueOf(position));

        ImageView userThumbnailImageView = (ImageView) view.findViewById(R.id.user_thumbnail);
        new SetBitmapFromNetworkTask(userThumbnailImageView).execute(user.getThumbnailUrl());

        TextView userNameTextView = (TextView) view.findViewById(R.id.user_name);
        userNameTextView.setText(user.getName());

        TextView userBiographyTextView = (TextView) view.findViewById(R.id.user_biography);
        userBiographyTextView.setText(user.getBiography());

        return view;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;2. convertViewがnullのときにだけ生成&lt;/h1&gt;

&lt;p&gt;recycle poolからreuseされたviewはconvertViewに入ってくるので、convertViewがnullじゃなければ、中身だけを書き換えて再利用するようにしたコードが以下です。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public class SampleAdapter2 extends ArrayAdapter&amp;lt;User&amp;gt; {

    public SampleAdapter2(Context context, int resource, List&amp;lt;User&amp;gt; objects) {
        super(context, resource, objects);
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        if (convertView == null) {
            convertView = View.inflate(getContext(), R.layout.list_item_user, parent);
        }

        User user = getItem(position);

        TextView numberTextView = (TextView) convertView.findViewById(R.id.number);
        numberTextView.setText(String.valueOf(position));

        ImageView userThumbnailImageView = (ImageView) convertView.findViewById(R.id.user_thumbnail);
        new SetBitmapFromNetworkTask(userThumbnailImageView).execute(user.getThumbnailUrl());

        TextView userNameTextView = (TextView) convertView.findViewById(R.id.user_name);
        userNameTextView.setText(user.getName());

        TextView userBiographyTextView = (TextView) convertView.findViewById(R.id.user_biography);
        userBiographyTextView.setText(user.getBiography());

        return convertView;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;3. convertViewがnullのときにだけ生成 + ViewHolderにviewをキャッシュ&lt;/h1&gt;

&lt;p&gt;convertViewが使いまわされたリストの一行のviewなのですが、その中のviewを毎回探索するのは無駄なので、ViewHolderクラスを作ってキャッシュさせます。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public class SampleAdapter3 extends ArrayAdapter&amp;lt;User&amp;gt; {

    private static class ViewHolder {
        TextView numberTextView;
        ImageView userThumbnailImageView;
        TextView userNameTextView;
        TextView userBiographyTextView;

        public ViewHolder(View view) {
            this.numberTextView = (TextView) view.findViewById(R.id.number);
            this.userThumbnailImageView = (ImageView) view.findViewById(R.id.user_thumbnail);
            this.userNameTextView = (TextView) view.findViewById(R.id.user_name);
            this.userBiographyTextView = (TextView) view.findViewById(R.id.user_biography);
        }
    }

    public SampleAdapter3(Context context, int resource, List&amp;lt;User&amp;gt; objects) {
        super(context, resource, objects);
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        ViewHolder holder;
        if (convertView == null) {
            convertView = View.inflate(getContext(), R.layout.list_item_user, parent);
            holder = new ViewHolder(convertView);
            convertView.setTag(holder);
        } else {
            holder = (ViewHolder) convertView.getTag();
        }

        User user = getItem(position);

        holder.numberTextView.setText(String.valueOf(position));
        new SetBitmapFromNetworkTask(holder.userThumbnailImageView).execute(user.getThumbnailUrl());
        holder.userNameTextView.setText(user.getName());
        holder.userBiographyTextView.setText(user.getBiography());

        return convertView;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;4. BindableAdapterを使う&lt;/h1&gt;

&lt;p&gt;「convertViewがnullのときは新しくviewを生成して、nullじゃなかったらViewに値をセットして」をコードに落としこむとこうなる感じです。
IDEのデフォルト機能でViewHolder以外のコードを生成できるので、コンストラクタの引数で迷わないし、型パラメータのおかげでitemをそのままViewにbindできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public class SampleAdapter4 extends BindableAdapter&amp;lt;User&amp;gt; {

    public SampleAdapter4(Context context, List&amp;lt;User&amp;gt; episodeList) {
        super(context, episodeList);
    }

    private static class ViewHolder {
        private TextView numberTextView;
        private ImageView userThumbnailImageView;
        private TextView userNameTextView;
        private TextView userBiographyTextView;

        ViewHolder(View view) {
            numberTextView = (TextView) view.findViewById(R.id.number);
            userThumbnailImageView = (ImageView) view.findViewById(R.id.user_thumbnail);
            userNameTextView = (TextView) view.findViewById(R.id.user_name);
            userBiographyTextView = (TextView) view.findViewById(R.id.user_biography);
        }
    }

    @Override
    public View newView(LayoutInflater inflater, int position, ViewGroup container) {
        View view =  inflater.inflate(R.layout.list_item_user, container, false);
        ViewHolder holder = new ViewHolder(view);
        view.setTag(holder);
        return view;
    }

    @Override
    public void bindView(User item, int position, View view) {
        ViewHolder holder = (ViewHolder) view.getTag();

        holder.numberTextView.setText(String.valueOf(position));
        new SetBitmapFromNetworkTask(holder.userThumbnailImageView).execute(item.getThumbnailUrl());
        holder.userNameTextView.setText(item.getName());
        holder.userBiographyTextView.setText(item.getBiography());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="java"&gt;public abstract class BindableAdapter&amp;lt;T&amp;gt; extends ArrayAdapter&amp;lt;T&amp;gt; {

    private LayoutInflater mInflater;

    public BindableAdapter(Context context, List&amp;lt;T&amp;gt; episodeList) {
        super(context, 0, episodeList);
        setup(context);
    }

    private void setup(Context context) {
        mInflater = LayoutInflater.from(context);
    }

    @Override
    public final View getView(int position, View view, ViewGroup container) {
        if (view == null) {
            view = newView(mInflater, position, container);
            if (view == null) {
                throw new IllegalStateException(&amp;quot;newView result must not be null.&amp;quot;);
            }
        }
        bindView(getItem(position), position, view);
        return view;
    }

    public abstract View newView(LayoutInflater inflater, int position, ViewGroup container);

    public abstract void bindView(T item, int position, View view);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でもViewHolderを手で書いたり、pluginで生成するのもあれなんですよね、 &lt;strong&gt;まさか来週の&lt;a href="https://github.com/potatotips/potatotips/wiki/potatotips-4"&gt;potatotips&lt;/a&gt;で@__gfx__さんがgradleでxmlからジャバコードを自動生成するわけじゃあるまいし(前フリ)&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>第7章 型や型クラスを自分で作ろう 後編</title>
    <link rel="alternate" href="http://rejasupotaro.github.io/2014/02/02/33.html"/>
    <id>http://rejasupotaro.github.io/2014/02/02/33.html</id>
    <published>2014-02-02T00:00:00+09:00</published>
    <updated>2014-02-09T01:15:20+09:00</updated>
    <author>
      <name>rejasupotaro</name>
    </author>
    <content type="html">&lt;h1&gt;前回やったこと&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;データ型の定義&lt;/li&gt;
&lt;li&gt;データ型のエクスポート&lt;/li&gt;
&lt;li&gt;レコード構文&lt;/li&gt;
&lt;li&gt;多相型と型引数&lt;/li&gt;
&lt;li&gt;インスタンスの自動導出&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/knjname/status/427053066030833664 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/nobkz/status/428789457068646401 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/nida_001/status/428789602015387648 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/tail_y/status/428822946719604736 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/VoQn/status/429091683783806976 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1&gt;今回やること&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;型シノニム

&lt;ul&gt;
&lt;li&gt;型シノニムの多相化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;再帰的なデータ構造&lt;/li&gt;
&lt;li&gt;演算子の定義&lt;/li&gt;
&lt;li&gt;型クラス

&lt;ul&gt;
&lt;li&gt;型クラスの定義&lt;/li&gt;
&lt;li&gt;型クラスのサブクラス&lt;/li&gt;
&lt;li&gt;型クラス制約&lt;/li&gt;
&lt;li&gt;多相性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Functor型クラス&lt;/li&gt;
&lt;li&gt;型の種類&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;型と新しい型(type and newtype)&lt;/h1&gt;

&lt;h2&gt;type&lt;/h2&gt;

&lt;p&gt;何章か前に出てきましたが &lt;code&gt;[Char]&lt;/code&gt; と &lt;code&gt;String&lt;/code&gt; は同値で、交換可能です。
ghciで &lt;code&gt;:i String&lt;/code&gt; としてみてください。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :i String
type String = [Char]    -- Defined in `GHC.Base&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;type 型構築子 型引数1 型引数2 ... = 元の型
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;typeは型のシノニムが定義されているのであって、新しい型が作られている訳ではありません。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ちょっと復習ですが、名前、年齢、身長、体重、電話番号を持つUserを表すデータ型は、&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;data User = User String Int Float Float String
    deriving (Show)

name :: User -&gt; String
name (User name _ _ _ _ ) = name

age :: User -&gt; Int
age (User _ age _ _ _) = age

height :: User -&gt; Float
height (User _ _ height _ _) = height

weight :: User -&gt; Float
weight (User _ _ _ weight _) = weight

phoneNumber :: User -&gt; String
phoneNumber (User _ _ _ _ phoneNumber) = phoneNumber
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このようになって、値構築子(値コンストラクタ)は関数なので &lt;code&gt;:type&lt;/code&gt; で型シグネチャを見ることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :t User
User :: String -&gt; Int -&gt; Float -&gt; Float -&gt; String -&gt; User
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;型シグネチャだけ見ても何を渡せばいいのか分からないということで、レコード構文もやりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;data User = User { name :: String
                 , age :: Int
                 , height :: Float
                 , weight :: Float
                 , phoneNumber :: String } deriving (Show)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :t User
User :: String -&gt; Int -&gt; Float -&gt; Float -&gt; String -&gt; User
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;typeを使うと下のように表すことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;type Name = String
type Age = Int
type Height = Float
type Weight = Float
type PhoneNumber = String

data User = User Name Age Height Weight PhoneNumber
    deriving (Show)

name :: User -&gt; Name
name (User name _ _ _ _ ) = name

age :: User -&gt; Age
age (User _ age _ _ _) = age

height :: User -&gt; Height
height (User _ _ height _ _) = height

weight :: User -&gt; Weight
weight (User _ _ _ weight _) = weight

phoneNumber :: User -&gt; PhoneNumber
phoneNumber (User _ _ _ _ phoneNumber) = phoneNumber
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :t User
User :: Name -&gt; Age -&gt; Height -&gt; Weight -&gt; PhoneNumber -&gt; User
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Haskellにはtypeの他にnewtypeもある。&lt;/p&gt;

&lt;h3&gt;newtype&lt;/h3&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;newtype 型構築子 型引数1 型引数2 ... = 値構築子 フィールド
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次のプログラムは &amp;quot;0123&amp;quot; のような数字列を表す型DigitStringを定義したものです。
関数atoiは、数字列を整数に変換する関数です。
引数が数字列であるべきことを強調するために、String型ではなくDigitString型の値を引数に要求します。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;newtype DigitString = DigitString String

atoi :: DigitString -&gt; Int
atoi (DigitString xs) = read xs
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; let n = DigitString &amp;quot;99&amp;quot;
&amp;gt; atoi n
99
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;typeは、既存の型に別名を付けるもので、newtypeは、値構築子数1、フィールド数1の型専用のdata宣言とでも言うべきもので、既存の型をラップした型を与えます。&lt;/p&gt;

&lt;h2&gt;data and type and newtype&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://hnakamur.blogspot.jp/2011/07/haskelldatatypenewtype.html"&gt;Haskellのdataとtypeとnewtypeの違い&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/5889696/difference-between-data-and-newtype-in-haskell"&gt;Difference between &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;newtype&lt;/code&gt; in Haskell&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/18204308/haskell-type-vs-data-constructor"&gt;Haskell Type vs Data Constructor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;型シノニムの多相化&lt;/h1&gt;

&lt;p&gt;前回のおさらい&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;型コンストラクタは型引数を取ることができます。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :i Maybe
data Maybe a = Nothing | Just a
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;値コンストラクタが引数を取って新しい値を生み出すものでしたが、同じように型コンストラクタは型引数を取って新しい型を作るものです。
MaybeにIntを渡すとMaybe Int型が得られますし、MaybeにStringを渡せばMaybe String型が得られます。
こうすることで、&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;data IntMaybe = INothing | IJust Int
data StringMaybe = SNothing | SJust String
data ShapeMaybe = ShNothing | ShJust Shape
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;のように、中身の型ごとに別々の型にする必要がなくなります。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;という感じで、型シノニムも多相化することができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;type AssocList k v = [(k, v)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうすることで、連想リストからキーを検索してくれる関数の型を &lt;code&gt;(Eq k) =&amp;gt; k -&gt; AssocList k v -&gt; Maybe v&lt;/code&gt; と書けるようになります。&lt;/p&gt;

&lt;h1&gt;haskell-jobqueue&lt;/h1&gt;

&lt;p&gt;&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/gree_tech/status/426666332973580288 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- haskell-jobqueue/src/Network/JobQueue/Types.hs
data Next a = Next {
    nextJob :: (Maybe a)
  , nextForks :: [(a, Maybe UTCTime)]
  }

type JobResult a = Either Failure (Next a)

setNextJob :: (Unit a) =&amp;gt; a -&gt; (JobResult a) -&gt; (JobResult a)
setNextJob x (Right next@(Next _ju _xs)) = Right next { nextJob = Just x }
setNextJob _ jr@(Left _) = jr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ジョブとJobResultを引数にして、JobResultのRightだったら次のジョブをセットしたJobResultを返して、LeftだったらそのままJobResultを返す。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;-- haskell-jobqueue/src/Network/JobQueue/JobQueue.hs
type FailureHandleFn a = Alert -&gt; String -&gt; String -&gt; Maybe (Job a) -&gt; IO (Maybe (Job a))
type AfterExecuteHandleFn a = Job a -&gt; IO ()

data (Unit a) =&amp;gt; Settings a = Settings {
    failureHandleFn :: FailureHandleFn a
  , afterExecuteFn :: AfterExecuteHandleFn a
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;長い型をtypeで表したりとかもする。&lt;/p&gt;

&lt;h1&gt;再帰的なデータ構造&lt;/h1&gt;

&lt;p&gt;時間があったら。&lt;/p&gt;

&lt;h1&gt;演算子の定義&lt;/h1&gt;

&lt;p&gt;すごいH本138ページあたりの演算子を定義する話。&lt;/p&gt;

&lt;p&gt;まず、演算子を定義する。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;infixr 5 :-:
data List a = Empty | a :-: (List a ) deriving (Show, Read, Eq, Ord)

infixr 5 ^++
(^++) :: List a -&gt; List a -&gt; List a
Empty ^++ ys ys
(x :-: xs) ^++ ys = x :-: (xs ^++ ys)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして使う。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; let a = 3 :-: 4 :-: 5 :-: Empty
&amp;gt; let b = 6 :-: 7 :-: Empty
&amp;gt; a ^++ b
3 :-: (4 :-: (5 :-: (6 :-: (7 :-: Empty))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://img.tiqav.com/8q.th.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;これを見てもあまり嬉しいと感じられないと思うので、自分で便利そうな演算子を何か一個、作ってみましょう。&lt;/p&gt;

&lt;h3&gt;例. 三項演算子っぽい何か&lt;/h3&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; [x &amp;gt; 5 ? 1 : 2 | x &amp;lt;- [1..10]]
&amp;gt; [2,2,2,2,2,1,1,1,1,1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(これは実現できないので、これっぽいなにかを)&lt;/p&gt;

&lt;p&gt;&lt;a href="http://d.hatena.ne.jp/marony0607/20111205/1323103005"&gt;Haskellの演算子について纏めてみた&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;型クラス&lt;/h1&gt;

&lt;p&gt;型クラスはインターフェイスのようなものです。型クラスは、特定の振る舞い(等値性判定だとか、順序の比較だとか、列挙だとか)を定義します。
定義されたとおりに振る舞うことができる型は、その型クラスのインスタンスである、といいます。&lt;/p&gt;

&lt;h2&gt;型クラスの定義&lt;/h2&gt;

&lt;p&gt;Eq型クラスを例に取りましょう。
Eqは等値性判定ができる(&lt;code&gt;==&lt;/code&gt; や &lt;code&gt;/=&lt;/code&gt;) という関数を定義している)値の型クラスです。
これは標準ライブラリにおけるEqの定義です。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;class Eq a where
  (==) :: a -&gt; a -&gt; Bool
  (/=) :: a -&gt; a -&gt; Bool
  x == y = not (x /= y)
  x /= y = not (x == y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クラスには関数定義と、オプションでデフォルト実装を書くことができます。&lt;/p&gt;

&lt;h2&gt;型クラスのサブクラスの定義&lt;/h2&gt;

&lt;p&gt;別の型クラスのサブクラスである型クラスを作ることもできます。
たとえばNumの型クラス宣言の最初のところは以下のようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;class (Eq a) =&amp;gt; Num a where
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;aはEqの振る舞いを実装している必要もある、というふうになります。&lt;/p&gt;

&lt;h2&gt;型クラス制約&lt;/h2&gt;

&lt;p&gt;リストの要素の和を求める関数sumの型がもし、&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;sum :: [Int] -&gt; Int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では具体的すぎます。かといって、&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;sum :: [a] -&gt; a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では広すぎです。そこで、次のような制約付きの宣言が使われます。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;sum :: Num a =&amp;gt; [a] -&gt; a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sumの型シグネチャ宣言におけるNum aは、型aがNumクラスのインスタンスでなければならないという制約を表します。
この制約は、型クラス制約、あるいは文脈(Context)と呼ばれます。&lt;/p&gt;

&lt;h2&gt;インスタンス化&lt;/h2&gt;

&lt;p&gt;ここで先週作った曜日のデータ型をみてみましょう。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;使える自動導出を全部使って、曜日のデータ型を作ってみましょう。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Eq, Ord, Show, Read, Bounded, Enum)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Eq、Ord、Show、Read、Bounded、Enumを自動導出していましたが、いくつかを手動で導出してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday

instance Eq Day where
  Monday == Monday = True
  Tuesday == Tuesday = True
  Wednesday == Wednesday = True
  Thursday == Thursday = True
  Friday == Friday = True
  Saturday == Saturday = True
  Sunday == Sunday = True
  _ == _ = False

instance Show Day where
  show Monday = &amp;quot;Monday&amp;quot;
  show Tuesday = &amp;quot;Tuesday&amp;quot;
  show Wednesday = &amp;quot;Wednesday&amp;quot;
  show Thursday = &amp;quot;Thursday&amp;quot;
  show Friday = &amp;quot;Friday&amp;quot;
  show Saturday = &amp;quot;Saturday&amp;quot;
  show Sunday = &amp;quot;Sunday&amp;quot;

instance Ord Day where
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; Monday == Sunday
False
&amp;gt; Monday /= Sunday
True
&amp;gt; Friday
Friday
&amp;gt; Monday &amp;lt; Tuesday
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では、まず引数をStringにして返すputs関数を作って、&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;puts :: (Show a) =&amp;gt; a -&gt; String
puts a = show a
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; puts &amp;#39;a&amp;#39;
&amp;quot;&amp;#39;a&amp;#39;&amp;quot;
&amp;gt; puts 1
&amp;quot;1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;それから、IntかCharしか受け取れないように型クラス制約を付けてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; puts &amp;#39;a&amp;#39;
&amp;quot;&amp;#39;a&amp;#39;&amp;quot;
&amp;gt; puts (1 :: Int)
&amp;quot;1&amp;quot;
&amp;gt; puts (1 :: Float)

&amp;lt;interactive&amp;gt;:14:1:
    No instance for (IntOrChar Float)
      arising from a use of `puts&amp;#39;
    Possible fix: add an instance declaration for (IntOrChar Float)
    In the expression: puts (1 :: Float)
    In an equation for `it&amp;#39;: it = puts (1 :: Float)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;多相性&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://yingtai.hatenablog.com/entry/2012/08/17/215648"&gt;Polymorphismまとめ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;パラメータ多相(parametric)&lt;/h3&gt;

&lt;p&gt;Haskellのリストを例に取ると、&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;length :: [a] -&gt; Int
length [] = 0
length (x:xs) = 1 + length xs
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; length [1,2,3]   -- [Int] -&gt; Int
3
&amp;gt; length &amp;quot;foobar&amp;quot;  -- [Char] -&gt; Int
6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この関数のアルゴリズムはリストの中身の型に依存しません。
言い換えれば、length関数は型に関わらず同じ操作をしています。
このようなタイプの多相をパラメータ多相と呼びます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C++のテンプレート&lt;/li&gt;
&lt;li&gt;Javaのジェネリクス&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;アドホック多相(ad-hoc)&lt;/h3&gt;

&lt;p&gt;Haskellでは型クラスにもとづき、型によって振る舞いを変えることをアドホック多相といいます。&lt;/p&gt;

&lt;p&gt;一般的にはアドホック多相にはオーバーロードと型キャストの二つがあります。&lt;/p&gt;

&lt;h4&gt;オーバーロード&lt;/h4&gt;

&lt;p&gt;Cを例に取ると、&lt;/p&gt;

&lt;pre&gt;&lt;code class="c"&gt;n = 1 + 3;        // 整数の加算
r = 1.5 + 2.5;    // 実数の加算
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでの &lt;code&gt;+&lt;/code&gt; 演算子の振る舞いは多相的ですが、実際の加算アルゴリズムは異なります。
この意味で、この2つの演算子が同じ &lt;code&gt;+&lt;/code&gt; であることの必然性はあまりなく、便宜上そうなっているだけ(ad-hoc)にすぎません。&lt;/p&gt;

&lt;h4&gt;型キャスト&lt;/h4&gt;

&lt;pre&gt;&lt;code class="c"&gt;x = 1.5 + 10;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このとき &lt;code&gt;+&lt;/code&gt; の左側は実数型、右側は整数型です。
このとき &lt;code&gt;+&lt;/code&gt; 演算子は見かけの上でだけ多相的です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C++/Javaのメソッドのオーバーロード&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;部分型多相(inclusion, subtyping)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Dog, Cat ∈ Animal&lt;/code&gt; という型の関係があったとき、
Animal型のオブジェクトにsayメソッドが適用できるならば、
Dog型、Cat型のオブジェクトにもsayメソッドが適用できる、といった多相です。&lt;/p&gt;

&lt;p&gt;オブジェクト指向で主に「多態」と呼ばれるタイプの多相。&lt;/p&gt;

&lt;h3&gt;ピンと来ない？&lt;/h3&gt;

&lt;p&gt;アドホック多相は、関数を適用する型を制限するのに対して、パラメータ多相は、具体的な型について言及しないことにより、新しい型に対応できるようにするということらしいです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.nslabs.jp/haskell-poly.rhtml"&gt;Haskellでの多態 (多相)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://chopl.in/blog/2012/11/06/introduction-to-typeclass-with-scala.html"&gt;Scalaで型クラス入門&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;Functor型クラス&lt;/h1&gt;

&lt;p&gt;Functor(関手)は、全体を写せる（map over）ものの型クラスです。
map overと聞いて、リストのmapを思い出しませんか？
あれも何かを写す操作の典型例です。&lt;/p&gt;

&lt;p&gt;Functor型クラスの実装を覗いてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;見てのとおりFunctorは1つの関数 fmap を持っており、デフォルト実装は提供しておりません。
どうやらfmapは、「ある型aから別の型bへの関数」と、「ある型aに適用されたファンクター値」を取り、「別の型bの方に適用されたファンクター値」を返す関数のようです。&lt;/p&gt;

&lt;p&gt;ところで、fmapの型宣言は何かに似ていると思いませんか？&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :t fmap
fmap :: Functor f =&amp;gt; (a -&gt; b) -&gt; f a -&gt; f b
&amp;gt; :t map
map :: (a -&gt; b) -&gt; [a] -&gt; [b]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mapは、「ある型から別の型への関数」と、「ある型のリスト」を取り、「別の型のリスト」を返す関数のようです。&lt;/p&gt;

&lt;p&gt;実は、リストはFunctor型クラスのインスタンスで、mapというのはリスト限定で動作するfmapなのです。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :i []
data [] a = [] | a : [a]        -- Defined in `GHC.Types&amp;#39;
instance Functor [] -- Defined in `GHC.Base&amp;#39;
...

instance Functor [] where
    fmap = map
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src="https://dl.dropboxusercontent.com/u/949822/qiita.com/131125-functors-applicative-and-monads-in-picture/fmap_list.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;リストにとってのfmapはただのmapであるため、2つの関数をリストに使った結果は一致します。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; fmap (*2) [1..3]
[2,4,6]
&amp;gt; map (*2) [1..3]
[2,4,6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Functorになれるのは、箱のような働きをする型です。
リスト以外にも例えばMaybe aがFunctorです。
MaybeはこんなふうにFunctorになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :i Maybe
data Maybe a = Nothing | Just a         -- Defined instance Functor Maybe -- Defined in `Data.Maybe&amp;#39;
...

instance Functor Maybe where
  fmap f (Just x) = Just (f x)
  fmap f Nothing = Nothing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fmapの実装はいたってシンプルです。
もし2つ目の引数が値の入ったJustだったら関数をJustの中身に適用して、Nothingだったら、Nothingを返します。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://yogsototh.github.io/Category-Theory-Presentation/categories/img/mp/boxfunctor.png" width="400"&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; fmap (++ &amp;quot; HEY GUYS IM INSIDE THE JUST&amp;quot;) (Just &amp;quot;Something serious.&amp;quot;)
Just &amp;quot;Something serious. HEY GUYS IM INSIDE THE JUST&amp;quot;
&amp;gt; fmap (++ &amp;quot; HEY GUYS IM INSIDE THE JUST&amp;quot;) Nothing
Nothing
&amp;gt; fmap (*2) (Just 200)
Just 400
&amp;gt; fmap (*2) Nothing
Nothing
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://qiita.com/suin/items/0255f0637921dcdfe83b"&gt;箱で考えるFunctor、ApplicativeそしてMonad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://ja.wikibooks.org/wiki/Haskell/%E5%9C%8F%E8%AB%96"&gt;Haskell/圏論&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://d.hatena.ne.jp/enakai00/20130912/1378970253"&gt;Functorを例として、圏論とHaskellの関係を分かりやすく説明してみるテスト&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;型の種類&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;[a]&lt;/code&gt; や &lt;code&gt;Maybe a&lt;/code&gt; のような型コンストラクタは、他の型を引数に取って具体型になります。
この振る舞いは、関数が値を引数に取って値を生み出すのとよく似ています。
それに、関数と同じく型コンストラクタも部分適用できます。
ここでは、型が型コンストラクタに適用される様子を形式的に定義してみます。&lt;/p&gt;

&lt;p&gt;3、&amp;quot;YEAH!&amp;quot;、takeWhileといった値（関数も受け取ったり渡したりできる値です）は、それぞれ固有の値を持っています。
型とは、値について何らかの推測をするための小さなラベルです。
そして型にも小さなラベルがついています。
その名は種類（kind）。種類は、「型の型」のようなものです。&lt;/p&gt;

&lt;p&gt;ghciの &lt;code&gt;:kind&lt;/code&gt; コマンドを使って、型の種類をみてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :k Int
Int :: *
&amp;gt; :k []
[] :: * -&gt; *
&amp;gt; :k Maybe
Maybe :: * -&gt; *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;*&lt;/code&gt; (スター)は、具体型を表す記号です。
&lt;code&gt;[]&lt;/code&gt; や &lt;code&gt;Maybe&lt;/code&gt; は1つの具体型(例えばInt)を取って具体型(例えばMaybe Int)を返す型コンストラクタであることが分かります。&lt;/p&gt;

&lt;p&gt;型コンストラクタに型引数を与えて、どんな種類の型ができるか調べてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :k [Char]
[Char] :: *
&amp;gt; :k Maybe Int
Maybe Int :: *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;型引数を与えると、具体型になりました。
型は値のラベルであり、種類は型のラベルである、という対応関係があるわけです。&lt;/p&gt;

&lt;p&gt;改めてFunctorの定義を見直すと、型変数fは1つの具体型を取って具体型を生み出す型として使われていることが見て取れます。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数の型宣言で値の型として使われていることから &lt;code&gt;f a&lt;/code&gt; や &lt;code&gt;f b&lt;/code&gt; は具体型でなければならないことが分かります。
Functorになるには &lt;code&gt;* -&gt; *&lt;/code&gt; という種類を持つ必要があるということが分かります。&lt;/p&gt;

&lt;h1&gt;今後のスケジュール&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://sugoihaskell.github.io/"&gt;sugoihaskell.github.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>2014/01/30</title>
    <link rel="alternate" href="http://rejasupotaro.github.io/2014/01/30/32.html"/>
    <id>http://rejasupotaro.github.io/2014/01/30/32.html</id>
    <published>2014-01-30T00:00:00+09:00</published>
    <updated>2014-02-09T01:15:20+09:00</updated>
    <author>
      <name>rejasupotaro</name>
    </author>
    <content type="html">&lt;h3&gt;〜今日の夕方〜&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;「僕らも&lt;a href="http://square.github.io/"&gt;Square&lt;/a&gt;みたいに積極的にライブラリ公開していきたいですね」&lt;br&gt;
「ですねー。maven centralにライブラリを上げたことありますか？」&lt;br&gt;
「ないですね。社内ライブラリはS3で管理しているので、mavenリポジトリはそっちに上げたことはありますが」&lt;br&gt;
「おっ、そうなんですか。じゃあmaven centralにも上げましょうよ！」&lt;br&gt;
「maven centralって面倒なんですよね。あっ、じゃあどっちが先にデプロイできるか競争しましょう！」  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/rejasupotaro/status/428818040407326721 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;今になってみるとこのとき &lt;a href="https://twitter.com/__gfx__"&gt;@&lt;strong&gt;gfx&lt;/strong&gt;&lt;/a&gt; さん、苦笑いしていたように思える。&lt;/p&gt;

&lt;h3&gt;家に帰ってやり方を調べる僕&lt;/h3&gt;

&lt;p&gt;&lt;a href="http://d.hatena.ne.jp/int128/20130409/1365434513"&gt;GradleでMaven Central Repositoryに成果物をリリースする&lt;/a&gt; とか &lt;a href="http://felipecsl.com/blog/2013/12/06/publishing-an-android-library-to-maven-central/"&gt;Publishing an Android Library to Maven Central With Gradle&lt;/a&gt; とかを読みました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;!!!Wait for your issue to be “Resolved”, that may take up to 2 business days (!!!)!!!
!!!That is really piece of cake compared to all this Java mess!!!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とてもためになりました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/rejasupotaro/status/428874546712567808 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;a href="{% oembed https://twitter.com/rejasupotaro/status/428883261347995649 %}"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;若者には厳しいシステムでした。&lt;a href="https://twitter.com/rejasupotaro/status/428006626071552000"&gt;拝承&lt;/a&gt;。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>進捗、例外、画面の切り替え</title>
    <link rel="alternate" href="http://rejasupotaro.github.io/2014/01/30/31.html"/>
    <id>http://rejasupotaro.github.io/2014/01/30/31.html</id>
    <published>2014-01-30T00:00:00+09:00</published>
    <updated>2014-02-09T01:15:20+09:00</updated>
    <author>
      <name>rejasupotaro</name>
    </author>
    <content type="html">&lt;p&gt;&lt;img src="https://dl.dropboxusercontent.com/u/54255753/blog/201401/state.png" width="600"&gt;&lt;/p&gt;

&lt;p&gt;ネットワークからデータを取ってくるときにProgressBarを回して、正常に読み込みたらコンテンツを、読み込めなかったらエラーを表示したいときどうしますか？&lt;/p&gt;

&lt;h1&gt;愚直な方法&lt;/h1&gt;

&lt;p&gt;全体をFrameLayoutにしてコンテンツの上にProgressView、ErrorViewになるように重ねる。&lt;/p&gt;

&lt;pre&gt;&lt;code class="xml"&gt;&amp;lt;FrameLayout
        android:background=&amp;quot;@android:color/holo_blue_light&amp;quot;
        android:layout_width=&amp;quot;match_parent&amp;quot;
        android:layout_height=&amp;quot;match_parent&amp;quot;
        &amp;gt;
    &amp;lt;LinearLayout
            android:orientation=&amp;quot;vertical&amp;quot;
            android:layout_gravity=&amp;quot;center&amp;quot;
            android:layout_width=&amp;quot;wrap_content&amp;quot;
            android:layout_height=&amp;quot;wrap_content&amp;quot;
            &amp;gt;
        &amp;lt;ImageView
                android:src=&amp;quot;@drawable/droid&amp;quot;
                android:layout_gravity=&amp;quot;center&amp;quot;
                android:layout_width=&amp;quot;wrap_content&amp;quot;
                android:layout_height=&amp;quot;wrap_content&amp;quot;
                /&amp;gt;
        &amp;lt;TextView
                android:text=&amp;quot;content&amp;quot;
                android:textSize=&amp;quot;@dimen/default_text_size&amp;quot;
                android:textColor=&amp;quot;@color/default_text_color&amp;quot;
                android:layout_gravity=&amp;quot;center&amp;quot;
                android:layout_width=&amp;quot;wrap_content&amp;quot;
                android:layout_height=&amp;quot;wrap_content&amp;quot;
                /&amp;gt;
    &amp;lt;/LinearLayout&amp;gt;
    &lt;!-- 以下を元のレイアウトに追加 --&gt;
    &amp;lt;include
        android:id=&amp;quot;@+id/progress_view&amp;quot;
        layout=&amp;quot;@layout/progress_view&amp;quot;
        android:visibility=&amp;quot;gone&amp;quot;
        /&amp;gt;
    &amp;lt;include
        android:id=&amp;quot;@+id/error_view&amp;quot;
        layout=&amp;quot;@layout/error_view&amp;quot;
        android:visibility=&amp;quot;gone&amp;quot;
        /&amp;gt;
&amp;lt;/FrameLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;続いてジャバ。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;@InjectView(R.id.progress_view) private View mProgressView;
@InjectView(R.id.error_view) private View mErrorView;

private void requestRssFeed() {
    mProgressView.show();
    mErrorView.hide();

    mRssFeedClient.request(new RssFeedClient.EpisodeClientResponseHandler() {
        @Override public void onSuccess(List&amp;lt;Episode&amp;gt; episodeList) {
            BusProvider.getInstance().post(new LoadEpisodeListCompleteEvent(episodeList));
            mProgressView.hide();
            mErrorView.hide();
        }

        @Override public void onFailure() {
            ToastUtils.show(getActivity(), &amp;quot;An error occurred while requesting rss feed.&amp;quot;);
            mProgressView.hide();
            mErrorView.show();
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;悪くはないけど、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;元のレイアウトをあまり変更したくない&lt;/li&gt;
&lt;li&gt;ProgressViewとErrorViewを別々に扱うので不安になる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;って書きながら思った。&lt;/p&gt;

&lt;h1&gt;もうちょっとスマートに表現&lt;/h1&gt;

&lt;p&gt;全体を囲むViewGroupがステートを持ってた方がいいかなと思って以下のように実装。&lt;/p&gt;

&lt;pre&gt;&lt;code class="xml"&gt;&lt;!-- FrameLayoutの代わりにStateFrameLayout(作った)を使う --&gt;
&amp;lt;rejasupotaro.sample.views.StateFrameLayout
        android:id=&amp;quot;@+id/state_frame_layout&amp;quot;
        android:background=&amp;quot;@android:color/holo_blue_light&amp;quot;
        android:layout_width=&amp;quot;match_parent&amp;quot;
        android:layout_height=&amp;quot;match_parent&amp;quot;
        &amp;gt;
    &amp;lt;LinearLayout
            android:orientation=&amp;quot;vertical&amp;quot;
            android:layout_gravity=&amp;quot;center&amp;quot;
            android:layout_width=&amp;quot;wrap_content&amp;quot;
            android:layout_height=&amp;quot;wrap_content&amp;quot;
            &amp;gt;
        &amp;lt;ImageView
                android:src=&amp;quot;@drawable/droid&amp;quot;
                android:layout_gravity=&amp;quot;center&amp;quot;
                android:layout_width=&amp;quot;wrap_content&amp;quot;
                android:layout_height=&amp;quot;wrap_content&amp;quot;
                /&amp;gt;
        &amp;lt;TextView
                android:text=&amp;quot;content&amp;quot;
                android:textSize=&amp;quot;@dimen/default_text_size&amp;quot;
                android:textColor=&amp;quot;@color/default_text_color&amp;quot;
                android:layout_gravity=&amp;quot;center&amp;quot;
                android:layout_width=&amp;quot;wrap_content&amp;quot;
                android:layout_height=&amp;quot;wrap_content&amp;quot;
                /&amp;gt;
    &amp;lt;/LinearLayout&amp;gt;
&amp;lt;/rejasupotaro.sample.views.StateFrameLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;続いてジャバ。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;@InjectView(R.id.state_frame_layout) private StateFrameLayout mStateFrameLayout;

private void requestRssFeed() {
    mStateFrameLayout.showProgress();

    mRssFeedClient.request(new RssFeedClient.EpisodeClientResponseHandler() {
        @Override public void onSuccess(List&amp;lt;Episode&amp;gt; episodeList) {
            BusProvider.getInstance().post(new LoadEpisodeListCompleteEvent(episodeList));
            mStateFrameLayout.showContent();
        }

        @Override public void onFailure() {
            ToastUtils.show(getActivity(), &amp;quot;An error occurred while requesting rss feed.&amp;quot;);
            mStateFrameLayout.showError();
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;元のレイアウトに変更はほぼ必要ない&lt;/li&gt;
&lt;li&gt;ステートの管理が少し楽になる&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;確認してみる&lt;/h3&gt;

&lt;p&gt;とりあえず2秒ごとにステートを変更してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;handler.postDelayed(new Runnable() {
        @Override public void run() {
            if (mStateFrameLayout.isStateProgress()) {
                mStateFrameLayout.showError();
            } else if (mStateFrameLayout.isStateError()) {
                mStateFrameLayout.showContent();
            } else {
                mStateFrameLayout.showProgress();
            }
            handler.postDelayed(this, TASK_INTERVAL_MILLIS);
        }
}, TASK_INTERVAL_MILLIS);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://gifzo.net/BMfi6eoXjgf.gif" width="200"&gt;&lt;/p&gt;

&lt;p&gt;ちゃんと動いてるっぽい。&lt;/p&gt;

&lt;h1&gt;StateFrameLayout&lt;/h1&gt;

&lt;p&gt;ContentViewがinflateされたタイミングでProgressViewとErrorViewを生成してセットし直してるだけです(なので動的にビューを追加しようとしたらちょっと変更が必要です)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class StateFrameLayout extends FrameLayout {

    private View mContentView;
    private View mProgressView;
    private View mErrorView;
    private State mState = State.CONTENT;

    public static enum State {
        CONTENT,
        PROGRESS,
        ERORR;
    }

    public State getState() {
        return mState;
    }

    public boolean isStateContent() {
        return (mState == State.CONTENT);
    }

    public boolean isStateProgress() {
        return (mState == State.PROGRESS);
    }

    public boolean isStateError() {
        return (mState == State.ERORR);
    }

    public StateFrameLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override public void onFinishInflate() {
        setupView();
    }

    private void setupView() {
        List&amp;lt;View&amp;gt; children = getAllChildren();
        removeAllViews();

        mContentView = inflateContentView(children);
        mProgressView = View.inflate(getContext(), R.layout.progress_view, null);
        mErrorView = View.inflate(getContext(), R.layout.error_view, null);

        addView(mContentView);
        addView(mProgressView);
        addView(mErrorView);
    }

    private List&amp;lt;View&amp;gt; getAllChildren() {
        List&amp;lt;View&amp;gt; children = new ArrayList&amp;lt;&amp;gt;();
        int childCount = getChildCount();
        for (int i = 0; i &amp;lt; childCount; i++) {
            children.add(getChildAt(i));
        }

        return children;
    }

    private View inflateContentView(List&amp;lt;View&amp;gt; viewList) {
        FrameLayout frameLayout = new FrameLayout(getContext());
        for (View view : viewList) {
            frameLayout.addView(view);
        }
        return frameLayout;
    }

    public void showProgress() {
        mContentView.setVisibility(View.GONE);
        mProgressView.setVisibility(View.VISIBLE);
        mErrorView.setVisibility(View.GONE);

        mState = State.PROGRESS;
    }

    public void showError() {
        mContentView.setVisibility(View.GONE);
        mProgressView.setVisibility(View.GONE);
        mErrorView.setVisibility(View.VISIBLE);

        mState = State.ERORR;
    }

    public void showContent() {
        mContentView.setVisibility(View.VISIBLE);
        mProgressView.setVisibility(View.GONE);
        mErrorView.setVisibility(View.GONE);

        mState = State.CONTENT;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ProgressViewとかErrorViewのレイアウトIDとか、エラー文言とかはXMLに書けると再利用性高まると思う。
属性は &lt;code&gt;namespace + attribute&lt;/code&gt; で取れる。たとえば &lt;code&gt;android:text&lt;/code&gt; ならこんな感じで。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// LayoutUtils.java とかにどうぞ
private static final String NAME_SPACE_ANDROID = &amp;quot;http://schemas.android.com/apk/res/android&amp;quot;;

public static final String getStringFromAttribute(Context context, AttributeSet attrs) {
    if (context == null || attrs == null) return &amp;quot;&amp;quot;;

    int textId = attrs.getAttributeResourceValue(NAME_SPACE_ANDROID, &amp;quot;text&amp;quot;, -1);
    if (textId == -1) {
        context.getString(textId)
    } else {
        return &amp;quot;&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとビューのデバッグするのにJakeWharton神の&lt;a href="https://github.com/JakeWharton/scalpel"&gt;Scalpel&lt;/a&gt;便利。&lt;/p&gt;

&lt;p&gt;&lt;img src="https://dl.dropboxusercontent.com/u/54255753/blog/201401/scalpel.png" width="200"&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://github.com/JakeWharton/scalpel/raw/master/images/sample.gif" width="200"&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>第7章 型や型クラスを自分で作ろう 前編</title>
    <link rel="alternate" href="http://rejasupotaro.github.io/2014/01/19/30.html"/>
    <id>http://rejasupotaro.github.io/2014/01/19/30.html</id>
    <published>2014-01-19T00:00:00+09:00</published>
    <updated>2014-02-10T16:04:20+09:00</updated>
    <author>
      <name>rejasupotaro</name>
    </author>
    <content type="html">&lt;h1&gt;すごいHaskell楽しく学ぼう輪読会とは&lt;/h1&gt;

&lt;h2&gt;経緯&lt;/h2&gt;

&lt;p&gt;2012年にSICP読書会に参加していてとてもためになったという話をしたのがきっかけで、社内でコンピュータサイエンスの勉強会をやろうということになりました。
そこで、2013年夏に社内でどの本を教科書にするかアンケートをおこないました。&lt;/p&gt;

&lt;h1&gt;教科書の候補に上がった本&lt;/h1&gt;

&lt;h2&gt;計算機プログラムの構造と解釈(SICP)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;言語：Scheme&lt;/li&gt;
&lt;li&gt;Web上での問題の解答の多さ(すくなくとも日本語での)は、他を圧倒してる。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="http://seaoak.cocolog-nifty.com/photos/uncategorized/2010/12/26/sicp_original.jpg" width="320px"&gt;&lt;/p&gt;

&lt;h2&gt;関数プログラミング入門(IFPH)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;言語：Haskell&lt;/li&gt;
&lt;li&gt;SICPよりちょっと難しい。一番最初にやる本ではない感じ(ってえらい人が言ってました)。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="http://ec2.images-amazon.com/images/I/41DBju8o5%2BL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU09_.jpg" width="320px"&gt;&lt;/p&gt;

&lt;h2&gt;プログラミングの基礎&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;言語：Ocaml&lt;/li&gt;
&lt;li&gt;著者による解答例あり。&lt;a href="http://d.hatena.ne.jp/nowokay/20090321#1237617054"&gt;いまSICPを読むのは時間の無駄 - きしだのはてな&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="http://ec2.images-amazon.com/images/I/51GBOf09hjL._SL500_AA300_.jpg" width="320px"&gt;&lt;/p&gt;

&lt;h2&gt;プログラミング言語の基礎概念&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;言語：Ocaml&lt;/li&gt;
&lt;li&gt;&lt;a href="http://d.hatena.ne.jp/nowokay/20111221#1324440641"&gt;「プログラミング言語の基礎概念」という本が非常にお気に入り - きしだのはてな&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="http://ecx.images-amazon.com/images/I/51PozlQUByL._SL500_AA300_.jpg" width="320px"&gt;&lt;/p&gt;

&lt;h2&gt;すごいHaskell楽しく学ぼう！&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;言語：Haskell&lt;/li&gt;
&lt;li&gt;Haskellを学ぶのならたぶんこの本が一番いい(ってえらい人が言ってました)。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="http://ecx.images-amazon.com/images/I/513ipzNg22L.jpg" width="320px"&gt;&lt;/p&gt;

&lt;h2&gt;エンタープライズアプリケーションアーキテクチャパターン(PoEAA)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;言語：Java, C#&lt;/li&gt;
&lt;li&gt;今回挙げた中では一番実用的な雰囲気がある。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="http://ecx.images-amazon.com/images/I/51TVM1CFHKL._BO2,204,203,200_PIsitb-sticker-arrow-click,-76_AA300_SH20_OU09_.jpg" width="320px"&gt;&lt;/p&gt;

&lt;h2&gt;コンピュータ・プログラミングの概念・技法・モデル(CTMCP)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;言語：Oz(Mozart)&lt;/li&gt;
&lt;li&gt;プログラミングパラダイムの種類をたくさん紹介しているのが良い。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="http://ec2.images-amazon.com/images/I/51iXhiKTamL._SL500_AA300_.jpg" width="320px"&gt;&lt;/p&gt;

&lt;h2&gt;型システム入門(TaPL)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;言語：Ocaml&lt;/li&gt;
&lt;li&gt;前提として離散数学、論理学、高階関数型プログラミング言語の知識、コンパイラの基礎的な概念が必要だけど面白そう。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="http://ec2.images-amazon.com/images/I/41gusdgRAkL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU09_.jpg" width="320px"&gt;&lt;/p&gt;

&lt;h2&gt;なるほどUNIXプロセス(Rubyで学ぶプロセスの基礎)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;言語：Ruby&lt;/li&gt;
&lt;li&gt;そらくんがオススメって言ってました。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="http://tatsu-zine.com/images/books/87/cover_s.jpg" width="320px"&gt;&lt;/p&gt;

&lt;h2&gt;アンケート結果&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;RubyとかRailsとかより、業務から離れたもの(パラダイムのちがうもの)を学びたいという意見があった。&lt;/li&gt;
&lt;li&gt;SICPは読んだことがある人が多かった。&lt;/li&gt;
&lt;li&gt;関数型言語をやりたいという意見が多かった。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;すごいHaskellたのしく学ぼう輪読会！&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;毎週月曜に担当者持ち回りで、担当者は読んだところを要約して聴きに来た人に説明する。&lt;/li&gt;
&lt;li&gt;聴きに来た人は分からないこととか思ったこととかあったらその場ですぐ発言する(そのためのマイク2本)。&lt;/li&gt;
&lt;li&gt;堅い感じではなくなるべくワイワイする。&lt;/li&gt;
&lt;li&gt;完走したら関東の関数型言語erを集めてLT大会をしたい。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;第7章 型や型クラスを自分で作ろう 前編&lt;/h1&gt;

&lt;p&gt;2週に渡って第7章を読みます。&lt;/p&gt;

&lt;h3&gt;今回学ぶこと&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Bool, Int, Char, Maybeみたいなデータ型を自分で作る方法を学ぶ&lt;/li&gt;
&lt;li&gt;データ型をモジュールとしてエクスポートしてみる&lt;/li&gt;
&lt;li&gt;レコード構文を使ってデータ型を定義する&lt;/li&gt;
&lt;li&gt;型引数について学ぶ&lt;/li&gt;
&lt;li&gt;インスタンスを自動導出してみる&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;データ型？&lt;/h2&gt;

&lt;p&gt;ghciを起動して &lt;code&gt;:i Bool&lt;/code&gt; とかやってみてください。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;Prelude&amp;gt; :i Bool
data Bool = False | True        -- Defined in `GHC.Types&amp;#39;
instance Bounded Bool -- Defined in `GHC.Enum&amp;#39;
instance Enum Bool -- Defined in `GHC.Enum&amp;#39;
instance Eq Bool -- Defined in `GHC.Classes&amp;#39;
instance Ord Bool -- Defined in `GHC.Classes&amp;#39;
instance Read Bool -- Defined in `GHC.Read&amp;#39;
instance Show Bool -- Defined in `GHC.Show&amp;#39;
Prelude&amp;gt; :i Maybe
data Maybe a = Nothing | Just a         -- Defined in `Data.Maybe&amp;#39;
instance Eq a =&amp;gt; Eq (Maybe a) -- Defined in `Data.Maybe&amp;#39;
instance Monad Maybe -- Defined in `Data.Maybe&amp;#39;
instance Functor Maybe -- Defined in `Data.Maybe&amp;#39;
instance Ord a =&amp;gt; Ord (Maybe a) -- Defined in `Data.Maybe&amp;#39;
instance Read a =&amp;gt; Read (Maybe a) -- Defined in `GHC.Read&amp;#39;
instance Show a =&amp;gt; Show (Maybe a) -- Defined in `GHC.Show&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Bool は False か True をとる&lt;/li&gt;
&lt;li&gt;Maybe a は Nothing か Just a をとる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これがデータ型です。&lt;/p&gt;

&lt;p&gt;今日話すところのデータ型 = 代数的データ型(A|B) = 集合論でいうところの直和型(A+B) = 直積型の総和&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://ja.wikipedia.org/wiki/%E4%BB%A3%E6%95%B0%E7%9A%84%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B"&gt;代数的データ型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;1個以上のコンストラクタがあり、各コンストラクタには0個以上の引数がある。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://ja.wikipedia.org/wiki/%E7%9B%B4%E5%92%8C#.E9.9B.86.E5.90.88.E3.81.AE.E7.9B.B4.E5.92.8C"&gt;直和&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;共通部分が空集合であるような二つの集合の和集合を表す。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://jutememo.blogspot.jp/2008/07/haskell-instance.html"&gt;Haskell の代数的データ型と型クラス、instance 宣言の関係&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="http://static.flickr.com/3004/2652003884_a25c578931.jpg" alt=""&gt;&lt;/p&gt;

&lt;h2&gt;新しいデータ型を定義する&lt;/h2&gt;

&lt;p&gt;data宣言は下のような構文になっています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data 型構築子 型引数 …
  = データ構築子A 型式A …
  | データ構築子B 型式B …
  ...
  | データ構築子N 型式N …
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;型構築子 (type constructor) (型コンストラクタ)

&lt;ul&gt;
&lt;li&gt;データ型の名前。必要であれば引数に型引数を指定できる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;データ構築子 (data constructor) (値コンストラクタ)

&lt;ul&gt;
&lt;li&gt;実際の値の生成やパターンマッチのときに使用する。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ちなみに &lt;code&gt;[]&lt;/code&gt; や &lt;code&gt;-&gt;&lt;/code&gt; も型構築子です。&lt;/p&gt;

&lt;h2&gt;データ型を操作する&lt;/h2&gt;

&lt;p&gt;はじめに、bookIdとtitleを持つBookinfoというデータ型を作ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;data Bookinfo = Book Int String
  deriving (Show)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように、値コンストラクタを書くときは、後ろに型を付け足すことができ、それらは値コンストラクタに与える引数の型になります。
型があって、その型を構成する部品を書くようなイメージです。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :t Book
Book :: Int -&gt; String -&gt; Bookinfo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実のところ、値コンストラクタは、そのデータ型の値を返す関数なのです。&lt;/p&gt;

&lt;p&gt;次に、BookからbookIdを取得する関数、titleを取得する関数を書いてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;bookId :: Bookinfo -&gt; Int
bookId (Book bookId _) = bookId

title :: Bookinfo -&gt; String
title (Book _ title) = title
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なんとなく理解できましたか？
では、次に長方形と円という2種類の図形を扱うことにしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;data Shape = Circle Float Float Float
           | Rectangle Float Float Float Float
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Circle値コンストラクタには、浮動小数を受け取るフィールドが3つあります。
ここでは、最初の2つのフィールドは円の中心の座標で、3つ目のフィールドは円の半径です。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :t Circle
Circle :: Float -&gt; Float -&gt; Float -&gt; Shape
&amp;gt; :t Rectangle
Rectangle :: Float -&gt; Float -&gt; Float -&gt; Float -&gt; Shape
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では、Shapeを引数に取って、その面積を返すarea関数を作ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;area :: Shape -&gt; Float
???
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;hint&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;値コンストラクタはパターンマッチに使えます。&lt;/li&gt;
&lt;li&gt;円周率は &lt;code&gt;pi&lt;/code&gt; が使えます。&lt;/li&gt;
&lt;li&gt;絶対値は &lt;code&gt;abs&lt;/code&gt; 関数が使えます。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;toString :: Bool -&gt; String
toString True = &amp;quot;True&amp;quot;
toString False = &amp;quot;False&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;実際の例&lt;/h2&gt;

&lt;h3&gt;&lt;a href="https://github.com/scotty-web/scotty"&gt;scotty-web/scotty&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Scottyは、RubyのSinatraライクなWAFです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cabal install scotty
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;{-# LANGUAGE OverloadedStrings #-}
import Web.Scotty

main = scotty 3000 $ do
  get &amp;quot;/&amp;quot; $ text &amp;quot;hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;scottyの例外の定義にデータ型を使っている。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;data Except = Forbidden | NotFound Int | StringEx String
  deriving (Show, Eq)

…

main :: IO ()
main = scottyT 3000 id id $ do
    middleware logStdoutDev
    defaultHandler handleEx -- 例外のハンドラをセットできる

    get &amp;quot;/&amp;quot; $ do
      ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;データ型をモジュールとしてエクスポートしてみる&lt;/h2&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;-- Shapes.hs
module
( Shapes
, area
)

data Shape = Circle Float Float Float
           | Rectangle Float Float Float Float
  deriving (Show)

area :: Shape -&gt; Float
area (Circle _ _ r) = pi * r ^ 2
area (Rectangle x1 y1 x2 y2) = (abs (x2 - x1)) * (abs (y2 - y1))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;-- Main.hs
import Shapes

main = do
  print $ Circle 1 1 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで実行すると、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ runghc Main.hs 

2.hs:4:11: Not in scope: data constructor `Circle&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と怒られると思います。
値コンストラクタは明示的に書かないといけないのかというと、&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;module
( Shapes
, Circle
, Rectangle
, area
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすると、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Shapes.hs:3:4: Not in scope: type constructor or class `Circle&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というわけで、この書き方は型コンストラクタか型クラスしかエクスポートできないみたいです。
値コンストラクタをエクスポートするには、&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;module
( Shapes(Circle, Rectangle)
, area
)

-- or

module
( Shapes(..) -- 普通はこっちの書き方をするようです
, area
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、特定のモジュールの中から何をインポートするかを指定することもできます。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;import Shapes(Shape(..))
import Shapes(area)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;レコード構文を使ってデータ型を定義する&lt;/h2&gt;

&lt;p&gt;名前、年齢、身長、体重、電話番号を持つユーザーを表すデータ型とそれぞれのデータにアクセスするための関数を作ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;data User = User String Int Float Float String
  deriving (Show)

name :: User -&gt; String
name (User name _ _ _ _ ) = name

age :: User -&gt; Int
age (User _ age _ _ _) = age

height :: User -&gt; Float
height (User _ _ height _ _) = height

weight :: User -&gt; Float
weight (User _ _ _ weight _) = weight

phoneNumber :: User -&gt; String
phoneNumber (User _ _ _ _ number) = number
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; User &amp;quot;John&amp;quot; 32 180 80 &amp;quot;123-4567&amp;quot;
User &amp;quot;John&amp;quot; 32 180.0 80.0 &amp;quot;123-4567&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;フィールドが多いと大変だし分かりづらいですね。
そこでレコード構文です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data 型構築子 型引数 ...
  = データ構築子A {フィールド名A :: 型A, … }
  | ...
  | データ構築子Z {フィールド名Z :: 型Z, ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この構文を使うと、先ほどの定義は&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;data User = User { name :: String
                 , age :: Int
                 , height :: Float
                 , weight :: Float
                 , phoneNumber :: String } deriving (Show)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうするとフィールドを取得する関数も自動で作られます。
また、レコード構文を使うと出力が変わります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; User &amp;quot;John&amp;quot; 32 180 80 &amp;quot;123-4567&amp;quot;
User {name = &amp;quot;John&amp;quot;, age = 32, height = 180.0, weight = 80.0, phoneNumber = &amp;quot;123-4567&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、値コンストラクタにフィールド名を渡すことで順番を変えることができます(すべてのフィールドを埋める必要はあります)。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; User {age = 32, height = 180.0, weight = 80.0, phoneNumber = &amp;quot;123-4567&amp;quot;, name = &amp;quot;John&amp;quot;}
User {name = &amp;quot;John&amp;quot;, age = 32, height = 180.0, weight = 80.0, phoneNumber = &amp;quot;123-4567&amp;quot;}

&amp;gt; User {age = 32, height = 180.0, weight = 80.0, phoneNumber = &amp;quot;123-4567&amp;quot;}

&amp;lt;interactive&amp;gt;:14:1:
    Warning: Fields of `User&amp;#39; not initialised: name
    In the expression:
      User
        {age = 32, height = 180.0, weight = 80.0, phoneNumber = &amp;quot;123-4567&amp;quot;}
    In an equation for `it&amp;#39;:
        it
          = User
              {age = 32, height = 180.0, weight = 80.0, phoneNumber = &amp;quot;123-4567&amp;quot;}

&amp;lt;interactive&amp;gt;:14:1:
    Warning: Fields of `User&amp;#39; not initialised: name
    In the expression:
      User
        {age = 32, height = 180.0, weight = 80.0, phoneNumber = &amp;quot;123-4567&amp;quot;}
    In an equation for `it&amp;#39;:
        it
          = User
              {age = 32, height = 180.0, weight = 80.0, phoneNumber = &amp;quot;123-4567&amp;quot;}
User {name = &amp;quot;*** Exception: &amp;lt;interactive&amp;gt;:14:1-72: Missing field in record construction Main.name
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;型引数&lt;/h2&gt;

&lt;p&gt;型コンストラクタは型引数を取ることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; :i Maybe
data Maybe a = Nothing | Just a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;値コンストラクタが引数を取って新しい値を生み出すものでしたが、同じように型コンストラクタは型引数を取って新しい型を作るものです。&lt;/p&gt;

&lt;p&gt;単なるMaybeという型の値は存在できません。&lt;/p&gt;

&lt;p&gt;MaybeにIntを渡すとMaybe Int型が得られますし、MaybeにStringを渡せばMaybe String型が得られます。&lt;/p&gt;

&lt;p&gt;こうすることで、&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;data IntMaybe = INothing | IJust Int
data StringMaybe = SNothing | SJust String
data ShapeMaybe = ShNothing | ShJust Shape
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように、中身の型ごとに別々の型にする必要がなくなります。&lt;/p&gt;

&lt;p&gt;実は、ここまですでにリスト型で型引数を使っていたりします。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; :i []
data [] a = [] | a : [a]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、型引数を持つ型は多相型と呼ばれます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://itpro.nikkeibp.co.jp/article/COLUMN/20060905/247156/"&gt;第2回　多相性（ポリモーフィズム）への理解を深める&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;多相性は「ある関数や型を、複数の型に対して使用できる」という性質を示す言葉です。こうした性質を持つ関数であれば、数値計算や文字列の連結、I/O（入出力）処理など一見全く違うように見えるような処理を、あたかも同じもののように扱うことができます。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;リストに複数の型を含める&lt;/h2&gt;

&lt;p&gt;Int、Float、Charを含んだリストを作るとします。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; [1, 1.0, &amp;#39;a&amp;#39;]

&amp;lt;interactive&amp;gt;:3:2:
    No instance for (Num Char)
      arising from the literal `1&amp;#39;
    Possible fix: add an instance declaration for (Num Char)
    In the expression: 1
    In the expression: [1, 1.0, &amp;#39;a&amp;#39;]
    In an equation for `it&amp;#39;: it = [1, 1.0, &amp;#39;a&amp;#39;]

&amp;lt;interactive&amp;gt;:3:5:
    No instance for (Fractional Char)
      arising from the literal `1.0&amp;#39;
    Possible fix: add an instance declaration for (Fractional Char)
    In the expression: 1.0
    In the expression: [1, 1.0, &amp;#39;a&amp;#39;]
    In an equation for `it&amp;#39;: it = [1, 1.0, &amp;#39;a&amp;#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そのままだと[] Numで型推論されてCharを含められなくなるので、新しいデータ型を定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;data MyType = I Int | F Float | C Char
  deriving (Show)

&amp;gt; [I 1, F 1.0, C &amp;#39;a&amp;#39;]
[I 1,F 1.0,C &amp;#39;a&amp;#39;]

&amp;gt; :t [I 1, F 1.0, C &amp;#39;a&amp;#39;]
[I 1, F 1.0, C &amp;#39;a&amp;#39;] :: [MyType]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうすることで、[] MyType型を作ることができます。&lt;/p&gt;

&lt;p&gt;では、[MyType]のリストからC要素を取り出すfilterC関数を作ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;-- 再帰を使う
filterC :: [MyType] -&gt; [MyType]
filterC _ [] = []
filterC (x:xs)
  | ???
  | ???

-- リスト内包表記を使う
[x | x &amp;lt;- [I 1, F 1.0, C &amp;#39;a&amp;#39;], ???]

-- filter関数を使う
filterC :: [MyType] -&gt; [MyType]
filterC = filter isC
  where ???
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;インスタンスを自動導出してみる&lt;/h2&gt;

&lt;p&gt;もし T が次のように定義された代数的データ型であるなら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data cx =&amp;gt; T u1 ... uk  = K1 t11 ... t1k1 | ...| Kn tn1 ... tnkn
  deriving (C1, ..., Cm)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(ここで m&amp;gt;=0 および括弧は m=1 の場合省略される)、 導出インスタンス宣言は、クラス C について、以下の条件が なりたてば、可能となる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C が Eq、Ord、Enum、Bounded、Show あるいは Read のうちの どれか。&lt;/li&gt;
&lt;li&gt;cx&amp;#39; =&amp;gt; C tij が構成要素の型 tij のそれぞれについて保存されているような 文脈 cx&amp;#39; がある。&lt;/li&gt;
&lt;li&gt;C が Bounded である場合。このとき、この型は列挙型 (すべての構成子が無引数)であるか、または構成子が一つしかないかの どちらかでなければならない。&lt;/li&gt;
&lt;li&gt;C が Enum である場合。このとき、この型は列挙型 でなければならない。&lt;/li&gt;
&lt;li&gt;T u1 ... ukを C のインスタンスとしたプログラム内の別の個所で明示的な インスタンス宣言があってはならない。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;整理すると、derivingキーワードを使うことで、特定の型クラスのインスタンス宣言を自動生成する(振る舞いがサポートされる)ことができます、ということです。
振る舞いがサポートされるということは、つまり関数が生えるということです。&lt;/p&gt;

&lt;h2&gt;EqおよびOrdの導出インスタンス&lt;/h2&gt;

&lt;p&gt;EqおよびOrdでは、(==)、(/=)、 compare、(&amp;lt;)、(&amp;lt;=)、(&amp;gt;)、 (&amp;gt;=)、max および min が導入されます。&lt;/p&gt;

&lt;p&gt;(==) や (/=) などで比較するときは、値コンストラクタの書くフィールドがすべて一致しているかを (==) で比較します。
なので、すべてのフィールドの型がEq型クラスのインスタンスでないと自動導出することはできません。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;-- 各フィールドが一致するか (==) で比較します
-- そのため、すべてのフィールドの型がEq型クラスのインスタンスでないと自動導出することはできません
data User = User { name :: String
                 , age :: Int
                 , height :: Float
                 , weight :: Float
                 , phoneNumber :: String }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Enumの導出インスタンス&lt;/h2&gt;

&lt;p&gt;Enumクラスに対する導出インスタンス宣言は列挙型(データ型が無引数構成子のみを含む型)(つまり引数なしの値コンストラクタ)にのみ可能です。
succ と pred 演算子で、左から右へ、次の値、前の値を与えられるようになります。&lt;/p&gt;

&lt;h2&gt;Boundedの導出インスタンス&lt;/h2&gt;

&lt;p&gt;Boundedでは minBound および maxBound というクラスメソッドが導入されます。&lt;/p&gt;

&lt;h2&gt;ReadおよびShowの導出インスタンス&lt;/h2&gt;

&lt;p&gt;ReadおよびShowでは showsPrec、readsPrec、showList、readListが導入されます。
これらは値から文字列への相互変換のために用いられます。&lt;/p&gt;

&lt;h2&gt;何曜日でもいいよ&lt;/h2&gt;

&lt;p&gt;使える自動導出を全部使って、曜日のデータ型を作ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Eq, Ord, Show, Read, Bounded, Enum)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;導入されたメソッドを呼んでみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class="haskell"&gt;&amp;gt; Wedneday
&amp;gt; show Wednesday
&amp;gt; read &amp;quot;Wednesday&amp;quot; :: Day
&amp;gt; Saturday == Sunday
&amp;gt; Monday `compare` Wednesday
&amp;gt; minBound :: Day
&amp;gt; succ Monday
&amp;gt; pred Saturday
&amp;gt; [minBound .. maxBound] :: [Day]
&lt;/code&gt;&lt;/pre&gt;
</content>
  </entry>
</feed>
